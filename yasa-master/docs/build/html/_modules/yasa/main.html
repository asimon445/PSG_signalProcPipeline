<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>yasa.main &#8212; yasa 0.3.0 documentation</title>
    <link rel="stylesheet" href="../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    <script type="text/javascript" src="../../_static/copybutton.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../../_static/js/jquery-1.11.0.min.js "></script>
<script type="text/javascript" src="../../_static/js/jquery-fix.js "></script>
<script type="text/javascript" src="../../_static/bootstrap-3.3.7/js/bootstrap.min.js "></script>
<script type="text/javascript" src="../../_static/bootstrap-sphinx.js "></script>

  </head><body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../index.html"><span><img src="../../_static/yasa_128x128.png"></span>
          yasa</a>
        <span class="navbar-text navbar-version pull-left"><b>0.3.0</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="../../api.html">Functions</a></li>
                <li><a href="../../changelog.html">What's new</a></li>
                <li><a href="../../contributing.html">Contribute</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"></ul>
</li>
              
            
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="body col-md-12 content" role="main">
      
  <h1>Source code for yasa.main</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">YASA (Yet Another Spindle Algorithm): fast and robust detection of spindles,</span>
<span class="sd">slow-waves, and rapid eye movements from sleep EEG recordings.</span>

<span class="sd">- Author: Raphael Vallat (www.raphaelvallat.com)</span>
<span class="sd">- GitHub: https://github.com/raphaelvallat/yasa</span>
<span class="sd">- License: BSD 3-Clause License</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">mne</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">signal</span>
<span class="kn">from</span> <span class="nn">mne.filter</span> <span class="k">import</span> <span class="n">filter_data</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">OrderedDict</span>
<span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="k">import</span> <span class="n">interp1d</span>
<span class="kn">from</span> <span class="nn">scipy.fftpack</span> <span class="k">import</span> <span class="n">next_fast_len</span>
<span class="kn">from</span> <span class="nn">sklearn.ensemble</span> <span class="k">import</span> <span class="n">IsolationForest</span>

<span class="kn">from</span> <span class="nn">.spectral</span> <span class="k">import</span> <span class="n">stft_power</span>
<span class="kn">from</span> <span class="nn">.numba</span> <span class="k">import</span> <span class="n">_detrend</span><span class="p">,</span> <span class="n">_rms</span>
<span class="kn">from</span> <span class="nn">.io</span> <span class="k">import</span> <span class="n">set_log_level</span><span class="p">,</span> <span class="n">is_tensorpac_installed</span><span class="p">,</span> <span class="n">is_pyriemann_installed</span>
<span class="kn">from</span> <span class="nn">.others</span> <span class="k">import</span> <span class="p">(</span><span class="n">moving_transform</span><span class="p">,</span> <span class="n">trimbothstd</span><span class="p">,</span> <span class="n">get_centered_indices</span><span class="p">,</span>
                     <span class="n">sliding_window</span><span class="p">,</span> <span class="n">_merge_close</span><span class="p">,</span> <span class="n">_zerocrossings</span><span class="p">)</span>


<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;yasa&#39;</span><span class="p">)</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;art_detect&#39;</span><span class="p">,</span> <span class="s1">&#39;spindles_detect&#39;</span><span class="p">,</span> <span class="s1">&#39;SpindlesResults&#39;</span><span class="p">,</span>
           <span class="s1">&#39;sw_detect&#39;</span><span class="p">,</span> <span class="s1">&#39;SWResults&#39;</span><span class="p">,</span> <span class="s1">&#39;rem_detect&#39;</span><span class="p">,</span> <span class="s1">&#39;REMResults&#39;</span><span class="p">]</span>


<span class="c1">#############################################################################</span>
<span class="c1"># DATA PREPROCESSING</span>
<span class="c1">#############################################################################</span>

<span class="k">def</span> <span class="nf">_check_data_hypno</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sf</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ch_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">hypno</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">include</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">check_amp</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper functions for preprocessing of data and hypnogram.&quot;&quot;&quot;</span>
    <span class="c1"># 1) Extract data as a 2D NumPy array</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">mne</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">BaseRaw</span><span class="p">):</span>
        <span class="n">sf</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;sfreq&#39;</span><span class="p">]</span>  <span class="c1"># Extract sampling frequency</span>
        <span class="n">ch_names</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">ch_names</span>  <span class="c1"># Extract channel names</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get_data</span><span class="p">()</span> <span class="o">*</span> <span class="mf">1e6</span>  <span class="c1"># Convert from V to uV</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">sf</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;sf must be specified if not using MNE Raw.&#39;</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;data must be 1D (times) or 2D (chan, times).&#39;</span>
    <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># Force to 2D array: (n_chan, n_samples)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
    <span class="n">n_chan</span><span class="p">,</span> <span class="n">n_samples</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span>

    <span class="c1"># 2) Check channel names</span>
    <span class="k">if</span> <span class="n">ch_names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ch_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;CHAN&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_chan</span><span class="p">)]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">ch_names</span><span class="p">)</span> <span class="o">==</span> <span class="n">n_chan</span>

    <span class="c1"># 3) Check hypnogram</span>
    <span class="k">if</span> <span class="n">hypno</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">hypno</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">hypno</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">hypno</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;Hypno must be one dimensional.&#39;</span>
        <span class="k">assert</span> <span class="n">hypno</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">n_samples</span><span class="p">,</span> <span class="s1">&#39;Hypno must have same size as data.&#39;</span>
        <span class="n">unique_hypno</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">hypno</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Number of unique values in hypno = </span><span class="si">%i</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">unique_hypno</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">include</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;include cannot be None if hypno is given&#39;</span>
        <span class="n">include</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">include</span><span class="p">))</span>
        <span class="k">assert</span> <span class="n">include</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;`include` must have at least one element.&#39;</span>
        <span class="k">assert</span> <span class="n">hypno</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">include</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;hypno and include &#39;</span>
                                                        <span class="s1">&#39;must have same dtype&#39;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">hypno</span><span class="p">,</span> <span class="n">include</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">(),</span> <span class="p">(</span><span class="s1">&#39;None of the stages specified &#39;</span>
                                               <span class="s1">&#39;in `include` are present in &#39;</span>
                                               <span class="s1">&#39;hypno.&#39;</span><span class="p">)</span>

    <span class="c1"># 4) Check data amplitude</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Number of samples in data = </span><span class="si">%i</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Sampling frequency = </span><span class="si">%.2f</span><span class="s1"> Hz&#39;</span><span class="p">,</span> <span class="n">sf</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Data duration = </span><span class="si">%.2f</span><span class="s1"> seconds&#39;</span><span class="p">,</span> <span class="n">n_samples</span> <span class="o">/</span> <span class="n">sf</span><span class="p">)</span>
    <span class="n">all_ptp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ptp</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">all_trimstd</span> <span class="o">=</span> <span class="n">trimbothstd</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">cut</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>
    <span class="n">bad_chan</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_chan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_chan</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Trimmed standard deviation of </span><span class="si">%s</span><span class="s1"> = </span><span class="si">%.4f</span><span class="s1"> uV&#39;</span>
                    <span class="o">%</span> <span class="p">(</span><span class="n">ch_names</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">all_trimstd</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Peak-to-peak amplitude of </span><span class="si">%s</span><span class="s1"> = </span><span class="si">%.4f</span><span class="s1"> uV&#39;</span>
                    <span class="o">%</span> <span class="p">(</span><span class="n">ch_names</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">all_ptp</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">check_amp</span> <span class="ow">and</span> <span class="ow">not</span><span class="p">(</span><span class="mf">0.1</span> <span class="o">&lt;</span> <span class="n">all_trimstd</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">1e3</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Wrong data amplitude for </span><span class="si">%s</span><span class="s1"> &#39;</span>
                         <span class="s1">&#39;(trimmed STD = </span><span class="si">%.3f</span><span class="s1">). Unit of data MUST be uV! &#39;</span>
                         <span class="s1">&#39;Channel will be skipped.&#39;</span>
                         <span class="o">%</span> <span class="p">(</span><span class="n">ch_names</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">all_trimstd</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="n">bad_chan</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1"># 5) Create sleep stage vector mask</span>
    <span class="k">if</span> <span class="n">hypno</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">hypno</span><span class="p">,</span> <span class="n">include</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">ch_names</span><span class="p">,</span> <span class="n">hypno</span><span class="p">,</span> <span class="n">include</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">n_chan</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">,</span>
            <span class="n">bad_chan</span><span class="p">)</span>


<span class="c1">#############################################################################</span>
<span class="c1"># BASE DETECTION RESULTS CLASS</span>
<span class="c1">#############################################################################</span>


<span class="k">class</span> <span class="nc">_DetectionResults</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Main class for detection results.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">ch_names</span><span class="p">,</span> <span class="n">hypno</span><span class="p">,</span> <span class="n">data_filt</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_events</span> <span class="o">=</span> <span class="n">events</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sf</span> <span class="o">=</span> <span class="n">sf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hypno</span> <span class="o">=</span> <span class="n">hypno</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ch_names</span> <span class="o">=</span> <span class="n">ch_names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data_filt</span> <span class="o">=</span> <span class="n">data_filt</span>

    <span class="k">def</span> <span class="nf">get_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;get_mask&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">yasa.others</span> <span class="k">import</span> <span class="n">_index_to_events</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_events</span><span class="p">[</span><span class="s1">&#39;IdxChannel&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">():</span>
            <span class="n">ev_chan</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_events</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_events</span><span class="p">[</span><span class="s1">&#39;IdxChannel&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">]</span>
            <span class="n">idx_ev</span> <span class="o">=</span> <span class="n">_index_to_events</span><span class="p">(</span>
                <span class="n">ev_chan</span><span class="p">[[</span><span class="s1">&#39;Start&#39;</span><span class="p">,</span> <span class="s1">&#39;End&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sf</span><span class="p">)</span>
            <span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">idx_ev</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">summary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event_type</span><span class="p">,</span> <span class="n">grp_chan</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">grp_stage</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">aggfunc</span><span class="o">=</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;summary&quot;&quot;&quot;</span>
        <span class="n">grouper</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">grp_stage</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="s1">&#39;Stage&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_events</span><span class="p">:</span>
            <span class="n">grouper</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;Stage&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">grp_chan</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="s1">&#39;Channel&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_events</span><span class="p">:</span>
            <span class="n">grouper</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;Channel&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">grouper</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_events</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">event_type</span> <span class="o">==</span> <span class="s1">&#39;spindles&#39;</span><span class="p">:</span>
            <span class="n">aggdict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Start&#39;</span><span class="p">:</span> <span class="s1">&#39;count&#39;</span><span class="p">,</span>
                       <span class="s1">&#39;Duration&#39;</span><span class="p">:</span> <span class="n">aggfunc</span><span class="p">,</span>
                       <span class="s1">&#39;Amplitude&#39;</span><span class="p">:</span> <span class="n">aggfunc</span><span class="p">,</span>
                       <span class="s1">&#39;RMS&#39;</span><span class="p">:</span> <span class="n">aggfunc</span><span class="p">,</span>
                       <span class="s1">&#39;AbsPower&#39;</span><span class="p">:</span> <span class="n">aggfunc</span><span class="p">,</span>
                       <span class="s1">&#39;RelPower&#39;</span><span class="p">:</span> <span class="n">aggfunc</span><span class="p">,</span>
                       <span class="s1">&#39;Frequency&#39;</span><span class="p">:</span> <span class="n">aggfunc</span><span class="p">,</span>
                       <span class="s1">&#39;Oscillations&#39;</span><span class="p">:</span> <span class="n">aggfunc</span><span class="p">,</span>
                       <span class="s1">&#39;Symmetry&#39;</span><span class="p">:</span> <span class="n">aggfunc</span><span class="p">}</span>

            <span class="c1"># if &#39;SOPhase&#39; in self._events:</span>
            <span class="c1">#     from scipy.stats import circmean</span>
            <span class="c1">#     aggdict[&#39;SOPhase&#39;] = lambda x: circmean(x, low=-np.pi,</span>
            <span class="c1">#                                             high=np.pi)</span>

        <span class="k">elif</span> <span class="n">event_type</span> <span class="o">==</span> <span class="s1">&#39;sw&#39;</span><span class="p">:</span>
            <span class="n">aggdict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Start&#39;</span><span class="p">:</span> <span class="s1">&#39;count&#39;</span><span class="p">,</span>
                       <span class="s1">&#39;Duration&#39;</span><span class="p">:</span> <span class="n">aggfunc</span><span class="p">,</span>
                       <span class="s1">&#39;ValNegPeak&#39;</span><span class="p">:</span> <span class="n">aggfunc</span><span class="p">,</span>
                       <span class="s1">&#39;ValPosPeak&#39;</span><span class="p">:</span> <span class="n">aggfunc</span><span class="p">,</span>
                       <span class="s1">&#39;PTP&#39;</span><span class="p">:</span> <span class="n">aggfunc</span><span class="p">,</span>
                       <span class="s1">&#39;Slope&#39;</span><span class="p">:</span> <span class="n">aggfunc</span><span class="p">,</span>
                       <span class="s1">&#39;Frequency&#39;</span><span class="p">:</span> <span class="n">aggfunc</span><span class="p">}</span>

            <span class="k">if</span> <span class="s1">&#39;PhaseAtSigmaPeak&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_events</span><span class="p">:</span>
                <span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="k">import</span> <span class="n">circmean</span>
                <span class="n">aggdict</span><span class="p">[</span><span class="s1">&#39;PhaseAtSigmaPeak&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">circmean</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">low</span><span class="o">=-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span>
                                                                 <span class="n">high</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
                <span class="n">aggdict</span><span class="p">[</span><span class="s1">&#39;ndPAC&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">aggfunc</span>

        <span class="k">else</span><span class="p">:</span>  <span class="c1"># REM</span>
            <span class="n">aggdict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Start&#39;</span><span class="p">:</span> <span class="s1">&#39;count&#39;</span><span class="p">,</span>
                       <span class="s1">&#39;Duration&#39;</span><span class="p">:</span> <span class="n">aggfunc</span><span class="p">,</span>
                       <span class="s1">&#39;LOCAbsValPeak&#39;</span><span class="p">:</span> <span class="n">aggfunc</span><span class="p">,</span>
                       <span class="s1">&#39;ROCAbsValPeak&#39;</span><span class="p">:</span> <span class="n">aggfunc</span><span class="p">,</span>
                       <span class="s1">&#39;LOCAbsRiseSlope&#39;</span><span class="p">:</span> <span class="n">aggfunc</span><span class="p">,</span>
                       <span class="s1">&#39;ROCAbsRiseSlope&#39;</span><span class="p">:</span> <span class="n">aggfunc</span><span class="p">,</span>
                       <span class="s1">&#39;LOCAbsFallSlope&#39;</span><span class="p">:</span> <span class="n">aggfunc</span><span class="p">,</span>
                       <span class="s1">&#39;ROCAbsFallSlope&#39;</span><span class="p">:</span> <span class="n">aggfunc</span><span class="p">}</span>

        <span class="c1"># Apply grouping</span>
        <span class="n">df_grp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_events</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">grouper</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="n">sort</span><span class="p">,</span>
                                      <span class="n">as_index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">agg</span><span class="p">(</span><span class="n">aggdict</span><span class="p">)</span>
        <span class="n">df_grp</span> <span class="o">=</span> <span class="n">df_grp</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;Start&#39;</span><span class="p">:</span> <span class="s1">&#39;Count&#39;</span><span class="p">})</span>

        <span class="c1"># Calculate density (= number per min of each stage)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hypno</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">grp_stage</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">stages</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_events</span><span class="p">[</span><span class="s1">&#39;Stage&#39;</span><span class="p">])</span>
            <span class="n">dur</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">st</span> <span class="ow">in</span> <span class="n">stages</span><span class="p">:</span>
                <span class="c1"># Get duration in minutes of each stage present in dataframe</span>
                <span class="n">dur</span><span class="p">[</span><span class="n">st</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hypno</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_hypno</span> <span class="o">==</span> <span class="n">st</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">/</span> <span class="p">(</span><span class="mi">60</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sf</span><span class="p">)</span>

            <span class="c1"># Insert new density column in grouped dataframe after count</span>
            <span class="n">df_grp</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span>
                <span class="n">loc</span><span class="o">=</span><span class="n">df_grp</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="s1">&#39;Count&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="s1">&#39;Density&#39;</span><span class="p">,</span>
                <span class="n">value</span><span class="o">=</span><span class="n">df_grp</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">rw</span><span class="p">:</span> <span class="n">rw</span><span class="p">[</span><span class="s1">&#39;Count&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">dur</span><span class="p">[</span><span class="n">rw</span><span class="p">[</span><span class="s1">&#39;Stage&#39;</span><span class="p">]],</span>
                                   <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">df_grp</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="n">grouper</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_sync_events</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">time_before</span><span class="p">,</span> <span class="n">time_after</span><span class="p">,</span>
                        <span class="n">filt</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)):</span>
        <span class="sd">&quot;&quot;&quot;get_sync_events (not for REM, spindles &amp; SW only)&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">yasa.others</span> <span class="k">import</span> <span class="n">get_centered_indices</span>
        <span class="k">assert</span> <span class="n">time_before</span> <span class="o">&gt;=</span> <span class="mi">0</span>
        <span class="k">assert</span> <span class="n">time_after</span> <span class="o">&gt;=</span> <span class="mi">0</span>
        <span class="n">bef</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sf</span> <span class="o">*</span> <span class="n">time_before</span><span class="p">)</span>
        <span class="n">aft</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sf</span> <span class="o">*</span> <span class="n">time_after</span><span class="p">)</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">bef</span><span class="p">,</span> <span class="n">aft</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int&#39;</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sf</span>

        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">filt</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">mne</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">filter_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sf</span><span class="p">,</span> <span class="n">l_freq</span><span class="o">=</span><span class="n">filt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                          <span class="n">h_freq</span><span class="o">=</span><span class="n">filt</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;fir&#39;</span><span class="p">,</span>
                                          <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>

        <span class="n">df_sync</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_events</span><span class="p">[</span><span class="s1">&#39;IdxChannel&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">():</span>
            <span class="n">ev_chan</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_events</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_events</span><span class="p">[</span><span class="s1">&#39;IdxChannel&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">]</span>
            <span class="n">peaks</span> <span class="o">=</span> <span class="p">(</span><span class="n">ev_chan</span><span class="p">[</span><span class="n">center</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sf</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
            <span class="c1"># Get centered indices</span>
            <span class="n">idx</span><span class="p">,</span> <span class="n">idx_nomask</span> <span class="o">=</span> <span class="n">get_centered_indices</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="n">peaks</span><span class="p">,</span> <span class="n">bef</span><span class="p">,</span> <span class="n">aft</span><span class="p">)</span>
            <span class="c1"># If no good epochs are returned raise a warning</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx_nomask</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                    <span class="s1">&#39;Time before and/or time after exceed data bounds, please &#39;</span>
                    <span class="s1">&#39;lower the temporal window around center. &#39;</span>
                    <span class="s1">&#39;Skipping channel.&#39;</span>
                <span class="p">)</span>
                <span class="k">continue</span>

            <span class="c1"># Get data at indices and time vector and convert to df</span>
            <span class="n">amps</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">idx</span><span class="p">]</span>
            <span class="n">df_chan</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">amps</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="n">df_chan</span><span class="p">[</span><span class="s1">&#39;Time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span>
            <span class="n">df_chan</span> <span class="o">=</span> <span class="n">df_chan</span><span class="o">.</span><span class="n">melt</span><span class="p">(</span><span class="n">id_vars</span><span class="o">=</span><span class="s1">&#39;Time&#39;</span><span class="p">,</span> <span class="n">var_name</span><span class="o">=</span><span class="s1">&#39;Event&#39;</span><span class="p">,</span>
                                   <span class="n">value_name</span><span class="o">=</span><span class="s1">&#39;Amplitude&#39;</span><span class="p">)</span>
            <span class="n">df_chan</span><span class="p">[</span><span class="s1">&#39;Channel&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ev_chan</span><span class="p">[</span><span class="s1">&#39;Channel&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">df_chan</span><span class="p">[</span><span class="s1">&#39;IdxChannel&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
            <span class="n">df_sync</span> <span class="o">=</span> <span class="n">df_sync</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df_chan</span><span class="p">,</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">df_sync</span>

    <span class="k">def</span> <span class="nf">plot_average</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event_type</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="s1">&#39;Peak&#39;</span><span class="p">,</span> <span class="n">time_before</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                     <span class="n">time_after</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">filt</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mf">4.5</span><span class="p">),</span>
                     <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;plot_average (not for REM, spindles &amp; SW only)&quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

        <span class="n">df_sync</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sync_events</span><span class="p">(</span><span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span> <span class="n">time_before</span><span class="o">=</span><span class="n">time_before</span><span class="p">,</span>
                                       <span class="n">time_after</span><span class="o">=</span><span class="n">time_after</span><span class="p">,</span>
                                       <span class="n">filt</span><span class="o">=</span><span class="n">filt</span><span class="p">)</span>

        <span class="k">assert</span> <span class="ow">not</span> <span class="n">df_sync</span><span class="o">.</span><span class="n">empty</span><span class="p">,</span> <span class="s2">&quot;Could not calculate event-locked data.&quot;</span>

        <span class="k">if</span> <span class="n">event_type</span> <span class="o">==</span> <span class="s1">&#39;spindles&#39;</span><span class="p">:</span>
            <span class="n">title</span> <span class="o">=</span> <span class="s2">&quot;Average spindle&quot;</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># &quot;sw&quot;:</span>
            <span class="n">title</span> <span class="o">=</span> <span class="s2">&quot;Average SW&quot;</span>

        <span class="c1"># Start figure</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">)</span>
        <span class="n">sns</span><span class="o">.</span><span class="n">lineplot</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">df_sync</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="s1">&#39;Time&#39;</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="s1">&#39;Amplitude&#39;</span><span class="p">,</span> <span class="n">hue</span><span class="o">=</span><span class="s1">&#39;Channel&#39;</span><span class="p">,</span>
                     <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># ax.legend(frameon=False, loc=&#39;lower right&#39;)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">df_sync</span><span class="p">[</span><span class="s1">&#39;Time&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">df_sync</span><span class="p">[</span><span class="s1">&#39;Time&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Time (sec)&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Amplitude (uV)&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ax</span>


<span class="c1">#############################################################################</span>
<span class="c1"># SPINDLES DETECTION</span>
<span class="c1">#############################################################################</span>


<div class="viewcode-block" id="spindles_detect"><a class="viewcode-back" href="../../generated/yasa.spindles_detect.html#yasa.spindles_detect">[docs]</a><span class="k">def</span> <span class="nf">spindles_detect</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sf</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ch_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">hypno</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">include</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">freq_sp</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">15</span><span class="p">),</span> <span class="n">freq_broad</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">30</span><span class="p">),</span>
                    <span class="n">duration</span><span class="o">=</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">min_distance</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span>
                    <span class="n">thresh</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;rel_pow&#39;</span><span class="p">:</span> <span class="mf">0.2</span><span class="p">,</span> <span class="s1">&#39;corr&#39;</span><span class="p">:</span> <span class="mf">0.65</span><span class="p">,</span> <span class="s1">&#39;rms&#39;</span><span class="p">:</span> <span class="mf">1.5</span><span class="p">},</span>
                    <span class="n">multi_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">remove_outliers</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Spindles detection.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : array_like</span>
<span class="sd">        Single or multi-channel data. Unit must be uV and shape (n_samples) or</span>
<span class="sd">        (n_chan, n_samples). Can also be a :py:class:`mne.io.BaseRaw`,</span>
<span class="sd">        in which case ``data``, ``sf``, and ``ch_names`` will be automatically</span>
<span class="sd">        extracted, and ``data`` will also be automatically converted from</span>
<span class="sd">        Volts (MNE) to micro-Volts (YASA).</span>
<span class="sd">    sf : float</span>
<span class="sd">        Sampling frequency of the data in Hz.</span>
<span class="sd">        Can be omitted if ``data`` is a :py:class:`mne.io.BaseRaw`.</span>
<span class="sd">    ch_names : list of str</span>
<span class="sd">        Channel names. Can be omitted if ``data`` is a</span>
<span class="sd">        :py:class:`mne.io.BaseRaw`.</span>
<span class="sd">    hypno : array_like</span>
<span class="sd">        Sleep stage (hypnogram). If the hypnogram is loaded, the</span>
<span class="sd">        detection will only be applied to the value defined in</span>
<span class="sd">        ``include`` (default = N1 + N2 + N3 sleep).</span>

<span class="sd">        The hypnogram must have the same number of samples as ``data``.</span>
<span class="sd">        To upsample your hypnogram, please refer to</span>
<span class="sd">        :py:func:`yasa.hypno_upsample_to_data`.</span>

<span class="sd">        .. note::</span>
<span class="sd">            The default hypnogram format in YASA is a 1D integer</span>
<span class="sd">            vector where:</span>

<span class="sd">            - -2 = Unscored</span>
<span class="sd">            - -1 = Artefact / Movement</span>
<span class="sd">            - 0 = Wake</span>
<span class="sd">            - 1 = N1 sleep</span>
<span class="sd">            - 2 = N2 sleep</span>
<span class="sd">            - 3 = N3 sleep</span>
<span class="sd">            - 4 = REM sleep</span>
<span class="sd">    include : tuple, list or int</span>
<span class="sd">        Values in ``hypno`` that will be included in the mask. The default is</span>
<span class="sd">        (1, 2, 3), meaning that the detection is applied on N1, N2 and N3</span>
<span class="sd">        sleep. This has no effect when ``hypno`` is None.</span>
<span class="sd">    freq_sp : tuple or list</span>
<span class="sd">        Spindles frequency range. Default is 12 to 15 Hz. Please note that YASA</span>
<span class="sd">        uses a FIR filter (implemented in MNE) with a 1.5Hz transition band,</span>
<span class="sd">        which means that for `freq_sp = (12, 15 Hz)`, the -6 dB points are</span>
<span class="sd">        located at 11.25 and 15.75 Hz.</span>
<span class="sd">    freq_broad : tuple or list</span>
<span class="sd">        Broad band frequency range. Default is 1 to 30 Hz.</span>
<span class="sd">    duration : tuple or list</span>
<span class="sd">        The minimum and maximum duration of the spindles.</span>
<span class="sd">        Default is 0.5 to 2 seconds.</span>
<span class="sd">    min_distance : int</span>
<span class="sd">        If two spindles are closer than ``min_distance`` (in ms), they are</span>
<span class="sd">        merged into a single spindles. Default is 500 ms.</span>
<span class="sd">    thresh : dict</span>
<span class="sd">        Detection thresholds:</span>

<span class="sd">        * ``&#39;rel_pow&#39;``: Relative power (= power ratio freq_sp / freq_broad).</span>
<span class="sd">        * ``&#39;corr&#39;``: Moving correlation between original signal and</span>
<span class="sd">          sigma-filtered signal.</span>
<span class="sd">        * ``&#39;rms&#39;``: Number of standard deviations above the mean of a moving</span>
<span class="sd">          root mean square of sigma-filtered signal.</span>

<span class="sd">        You can disable one or more threshold by putting ``None`` instead:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            thresh = {&#39;rel_pow&#39;: None, &#39;corr&#39;: 0.65, &#39;rms&#39;: 1.5}</span>
<span class="sd">            thresh = {&#39;rel_pow&#39;: None, &#39;corr&#39;: None, &#39;rms&#39;: 3}</span>
<span class="sd">    multi_only : boolean</span>
<span class="sd">        Define the behavior of the multi-channel detection. If True, only</span>
<span class="sd">        spindles that are present on at least two channels are kept. If False,</span>
<span class="sd">        no selection is applied and the output is just a concatenation of the</span>
<span class="sd">        single-channel detection dataframe. Default is False.</span>
<span class="sd">    remove_outliers : boolean</span>
<span class="sd">        If True, YASA will automatically detect and remove outliers spindles</span>
<span class="sd">        using :py:class:`sklearn.ensemble.IsolationForest`.</span>
<span class="sd">        The outliers detection is performed on all the spindles</span>
<span class="sd">        parameters with the exception of the ``Start``, ``Peak``, ``End``,</span>
<span class="sd">        ``Stage``, and ``SOPhase`` columns.</span>
<span class="sd">        YASA uses a random seed (42) to ensure reproducible results.</span>
<span class="sd">        Note that this step will only be applied if there are more than 50</span>
<span class="sd">        detected spindles in the first place. Default to False.</span>
<span class="sd">    verbose : bool or str</span>
<span class="sd">        Verbose level. Default (False) will only print warning and error</span>
<span class="sd">        messages. The logging levels are &#39;debug&#39;, &#39;info&#39;, &#39;warning&#39;, &#39;error&#39;,</span>
<span class="sd">        and &#39;critical&#39;. For most users the choice is between &#39;info&#39;</span>
<span class="sd">        (or ``verbose=True``) and warning (``verbose=False``).</span>

<span class="sd">        .. versionadded:: 0.2.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    sp : :py:class:`yasa.SpindlesResults`</span>
<span class="sd">        To get the full detection dataframe, use:</span>

<span class="sd">        &gt;&gt;&gt; sp = spindles_detect(...)</span>
<span class="sd">        &gt;&gt;&gt; sp.summary()</span>

<span class="sd">        This will give a :py:class:`pandas.DataFrame` where each row is a</span>
<span class="sd">        detected spindle and each column is a parameter (= feature or property)</span>
<span class="sd">        of this spindle. To get the average spindles parameters per channel and</span>
<span class="sd">        sleep stage:</span>

<span class="sd">        &gt;&gt;&gt; sp.summary(grp_chan=True, grp_stage=True)</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The parameters that are calculated for each spindle are:</span>

<span class="sd">    * ``&#39;Start&#39;``: Start time of the spindle, in seconds from the beginning of</span>
<span class="sd">      data.</span>
<span class="sd">    * ``&#39;Peak&#39;``: Time at the most prominent spindle peak (in seconds).</span>
<span class="sd">    * ``&#39;End&#39;`` : End time (in seconds).</span>
<span class="sd">    * ``&#39;Duration&#39;``: Duration (in seconds)</span>
<span class="sd">    * ``&#39;Amplitude&#39;``: Peak-to-peak amplitude of the (detrended) spindle in</span>
<span class="sd">      the raw data (in µV).</span>
<span class="sd">    * ``&#39;RMS&#39;``: Root-mean-square (in µV)</span>
<span class="sd">    * ``&#39;AbsPower&#39;``: Median absolute power (in log10 µV^2),</span>
<span class="sd">      calculated from the Hilbert-transform of the ``freq_sp`` filtered signal.</span>
<span class="sd">    * ``&#39;RelPower&#39;``: Median relative power of the ``freq_sp`` band in spindle</span>
<span class="sd">      calculated from a short-term fourier transform and expressed as a</span>
<span class="sd">      proportion of the total power in ``freq_broad``.</span>
<span class="sd">    * ``&#39;Frequency&#39;``: Median instantaneous frequency of spindle (in Hz),</span>
<span class="sd">      derived from an Hilbert transform of the ``freq_sp`` filtered signal.</span>
<span class="sd">    * ``&#39;Oscillations&#39;``: Number of oscillations (= number of positive peaks</span>
<span class="sd">      in spindle.)</span>
<span class="sd">    * ``&#39;Symmetry&#39;``: Location of the most prominent peak of spindle,</span>
<span class="sd">      normalized from 0 (start) to 1 (end). Ideally this value should be close</span>
<span class="sd">      to 0.5, indicating that the most prominent peak is halfway through the</span>
<span class="sd">      spindle.</span>
<span class="sd">    * ``&#39;Stage&#39;`` : Sleep stage during which spindle occured, if ``hypno``</span>
<span class="sd">      was provided.</span>

<span class="sd">      All parameters are calculated from the broadband-filtered EEG</span>
<span class="sd">      (frequency range defined in ``freq_broad``).</span>

<span class="sd">    For better results, apply this detection only on artefact-free NREM sleep.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    The sleep spindles detection algorithm is based on:</span>

<span class="sd">    * Lacourse, K., Delfrate, J., Beaudry, J., Peppard, P., &amp; Warby, S. C.</span>
<span class="sd">      (2018). `A sleep spindle detection algorithm that emulates human expert</span>
<span class="sd">      spindle scoring. &lt;https://doi.org/10.1016/j.jneumeth.2018.08.014&gt;`_</span>
<span class="sd">      Journal of Neuroscience Methods.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    For a walkthrough of the spindles detection, please refer to the following</span>
<span class="sd">    Jupyter notebooks:</span>

<span class="sd">    https://github.com/raphaelvallat/yasa/blob/master/notebooks/01_spindles_detection.ipynb</span>

<span class="sd">    https://github.com/raphaelvallat/yasa/blob/master/notebooks/02_spindles_detection_multi.ipynb</span>

<span class="sd">    https://github.com/raphaelvallat/yasa/blob/master/notebooks/03_spindles_detection_NREM_only.ipynb</span>

<span class="sd">    https://github.com/raphaelvallat/yasa/blob/master/notebooks/04_spindles_slow_fast.ipynb</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">set_log_level</span><span class="p">(</span><span class="n">verbose</span><span class="p">)</span>

    <span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">ch_names</span><span class="p">,</span> <span class="n">hypno</span><span class="p">,</span> <span class="n">include</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">n_chan</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">,</span> <span class="n">bad_chan</span>
     <span class="p">)</span> <span class="o">=</span> <span class="n">_check_data_hypno</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">ch_names</span><span class="p">,</span> <span class="n">hypno</span><span class="p">,</span> <span class="n">include</span><span class="p">)</span>

    <span class="c1"># If all channels are bad</span>
    <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">bad_chan</span><span class="p">)</span> <span class="o">==</span> <span class="n">n_chan</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;All channels have bad amplitude. Returning None.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># Check detection thresholds</span>
    <span class="k">if</span> <span class="s1">&#39;rel_pow&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">thresh</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">thresh</span><span class="p">[</span><span class="s1">&#39;rel_pow&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.20</span>
    <span class="k">if</span> <span class="s1">&#39;corr&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">thresh</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">thresh</span><span class="p">[</span><span class="s1">&#39;corr&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.65</span>
    <span class="k">if</span> <span class="s1">&#39;rms&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">thresh</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">thresh</span><span class="p">[</span><span class="s1">&#39;rms&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.5</span>
    <span class="n">do_rel_pow</span> <span class="o">=</span> <span class="n">thresh</span><span class="p">[</span><span class="s1">&#39;rel_pow&#39;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;none&quot;</span><span class="p">,</span> <span class="s2">&quot;None&quot;</span><span class="p">]</span>
    <span class="n">do_corr</span> <span class="o">=</span> <span class="n">thresh</span><span class="p">[</span><span class="s1">&#39;corr&#39;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;none&quot;</span><span class="p">,</span> <span class="s2">&quot;None&quot;</span><span class="p">]</span>
    <span class="n">do_rms</span> <span class="o">=</span> <span class="n">thresh</span><span class="p">[</span><span class="s1">&#39;rms&#39;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;none&quot;</span><span class="p">,</span> <span class="s2">&quot;None&quot;</span><span class="p">]</span>
    <span class="n">n_thresh</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">do_rel_pow</span><span class="p">,</span> <span class="n">do_corr</span><span class="p">,</span> <span class="n">do_rms</span><span class="p">])</span>
    <span class="k">assert</span> <span class="n">n_thresh</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;At least one threshold must be defined.&#39;</span>

    <span class="c1"># Filtering</span>
    <span class="n">nfast</span> <span class="o">=</span> <span class="n">next_fast_len</span><span class="p">(</span><span class="n">n_samples</span><span class="p">)</span>
    <span class="c1"># 1) Broadband bandpass filter (optional -- careful of lower freq for PAC)</span>
    <span class="n">data_broad</span> <span class="o">=</span> <span class="n">filter_data</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">freq_broad</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">freq_broad</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                             <span class="n">method</span><span class="o">=</span><span class="s1">&#39;fir&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1"># 2) Sigma bandpass filter</span>
    <span class="c1"># The width of the transition band is set to 1.5 Hz on each side,</span>
    <span class="c1"># meaning that for freq_sp = (12, 15 Hz), the -6 dB points are located at</span>
    <span class="c1"># 11.25 and 15.75 Hz.</span>
    <span class="n">data_sigma</span> <span class="o">=</span> <span class="n">filter_data</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">freq_sp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">freq_sp</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                             <span class="n">l_trans_bandwidth</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span> <span class="n">h_trans_bandwidth</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span>
                             <span class="n">method</span><span class="o">=</span><span class="s1">&#39;fir&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Hilbert power (to define the instantaneous frequency / power)</span>
    <span class="n">analytic</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">hilbert</span><span class="p">(</span><span class="n">data_sigma</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="n">nfast</span><span class="p">)[:,</span> <span class="p">:</span><span class="n">n_samples</span><span class="p">]</span>
    <span class="n">inst_phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">analytic</span><span class="p">)</span>
    <span class="n">inst_pow</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">analytic</span><span class="p">))</span>
    <span class="n">inst_freq</span> <span class="o">=</span> <span class="p">(</span><span class="n">sf</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">inst_phase</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>

    <span class="c1"># Extract the SO signal for coupling</span>
    <span class="c1"># if coupling:</span>
    <span class="c1">#     # We need to use the original (non-filtered data)</span>
    <span class="c1">#     data_so = filter_data(data, sf, freq_so[0], freq_so[1], method=&#39;fir&#39;,</span>
    <span class="c1">#                           l_trans_bandwidth=0.1, h_trans_bandwidth=0.1,</span>
    <span class="c1">#                           verbose=0)</span>
    <span class="c1">#     # Now extract the instantaneous phase using Hilbert transform</span>
    <span class="c1">#     so_phase = np.angle(signal.hilbert(data_so, N=nfast)[:, :n_samples])</span>

    <span class="c1"># Initialize empty output dataframe</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_chan</span><span class="p">):</span>

        <span class="c1"># ####################################################################</span>
        <span class="c1"># START SINGLE CHANNEL DETECTION</span>
        <span class="c1"># ####################################################################</span>

        <span class="c1"># First, skip channels with bad data amplitude</span>
        <span class="k">if</span> <span class="n">bad_chan</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="k">continue</span>

        <span class="c1"># Compute the pointwise relative power using interpolated STFT</span>
        <span class="c1"># Here we use a step of 200 ms to speed up the computation.</span>
        <span class="c1"># Note that even if the threshold is None we still need to calculate it</span>
        <span class="c1"># for the individual spindles parameter (RelPow).</span>
        <span class="n">f</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">Sxx</span> <span class="o">=</span> <span class="n">stft_power</span><span class="p">(</span><span class="n">data_broad</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="n">sf</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">step</span><span class="o">=.</span><span class="mi">2</span><span class="p">,</span>
                               <span class="n">band</span><span class="o">=</span><span class="n">freq_broad</span><span class="p">,</span> <span class="n">interp</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">idx_sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">f</span> <span class="o">&gt;=</span> <span class="n">freq_sp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">f</span> <span class="o">&lt;=</span> <span class="n">freq_sp</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">rel_pow</span> <span class="o">=</span> <span class="n">Sxx</span><span class="p">[</span><span class="n">idx_sigma</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Let&#39;s interpolate `rel_pow` to get one value per sample</span>
        <span class="c1"># Note that we could also have use the `interp=True` in the</span>
        <span class="c1"># `stft_power` function, however 2D interpolation is much slower than</span>
        <span class="c1"># 1D interpolation.</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">rel_pow</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;cubic&#39;</span><span class="p">,</span> <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_samples</span><span class="p">)</span> <span class="o">/</span> <span class="n">sf</span>
        <span class="n">rel_pow</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">do_corr</span><span class="p">:</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">mcorr</span> <span class="o">=</span> <span class="n">moving_transform</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">data_sigma</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="n">y</span><span class="o">=</span><span class="n">data_broad</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span>
                                        <span class="n">sf</span><span class="o">=</span><span class="n">sf</span><span class="p">,</span> <span class="n">window</span><span class="o">=.</span><span class="mi">3</span><span class="p">,</span> <span class="n">step</span><span class="o">=.</span><span class="mi">1</span><span class="p">,</span>
                                        <span class="n">method</span><span class="o">=</span><span class="s1">&#39;corr&#39;</span><span class="p">,</span> <span class="n">interp</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">do_rms</span><span class="p">:</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">mrms</span> <span class="o">=</span> <span class="n">moving_transform</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">data_sigma</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="n">sf</span><span class="o">=</span><span class="n">sf</span><span class="p">,</span>
                                       <span class="n">window</span><span class="o">=.</span><span class="mi">3</span><span class="p">,</span> <span class="n">step</span><span class="o">=.</span><span class="mi">1</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;rms&#39;</span><span class="p">,</span>
                                       <span class="n">interp</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># Let&#39;s define the thresholds</span>
            <span class="k">if</span> <span class="n">hypno</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">thresh_rms</span> <span class="o">=</span> <span class="n">mrms</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span> <span class="o">+</span> <span class="n">thresh</span><span class="p">[</span><span class="s1">&#39;rms&#39;</span><span class="p">]</span> <span class="o">*</span> \
                    <span class="n">trimbothstd</span><span class="p">(</span><span class="n">mrms</span><span class="p">,</span> <span class="n">cut</span><span class="o">=</span><span class="mf">0.10</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">thresh_rms</span> <span class="o">=</span> <span class="n">mrms</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span> <span class="o">+</span> <span class="n">thresh</span><span class="p">[</span><span class="s1">&#39;rms&#39;</span><span class="p">]</span> <span class="o">*</span> \
                    <span class="n">trimbothstd</span><span class="p">(</span><span class="n">mrms</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span> <span class="n">cut</span><span class="o">=</span><span class="mf">0.10</span><span class="p">)</span>
            <span class="c1"># Avoid too high threshold caused by Artefacts / Motion during Wake</span>
            <span class="n">thresh_rms</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">thresh_rms</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Moving RMS threshold = </span><span class="si">%.3f</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">thresh_rms</span><span class="p">)</span>

        <span class="c1"># Boolean vector of supra-threshold indices</span>
        <span class="n">idx_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_samples</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">do_rel_pow</span><span class="p">:</span>
            <span class="n">idx_rel_pow</span> <span class="o">=</span> <span class="p">(</span><span class="n">rel_pow</span> <span class="o">&gt;=</span> <span class="n">thresh</span><span class="p">[</span><span class="s1">&#39;rel_pow&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">idx_sum</span> <span class="o">+=</span> <span class="n">idx_rel_pow</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;N supra-theshold relative power = </span><span class="si">%i</span><span class="s1">&#39;</span><span class="p">,</span>
                        <span class="n">idx_rel_pow</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">do_corr</span><span class="p">:</span>
            <span class="n">idx_mcorr</span> <span class="o">=</span> <span class="p">(</span><span class="n">mcorr</span> <span class="o">&gt;=</span> <span class="n">thresh</span><span class="p">[</span><span class="s1">&#39;corr&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">idx_sum</span> <span class="o">+=</span> <span class="n">idx_mcorr</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;N supra-theshold moving corr = </span><span class="si">%i</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">idx_mcorr</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">do_rms</span><span class="p">:</span>
            <span class="n">idx_mrms</span> <span class="o">=</span> <span class="p">(</span><span class="n">mrms</span> <span class="o">&gt;=</span> <span class="n">thresh_rms</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">idx_sum</span> <span class="o">+=</span> <span class="n">idx_mrms</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;N supra-theshold moving RMS = </span><span class="si">%i</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">idx_mrms</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>

        <span class="c1"># Make sure that we do not detect spindles outside mask</span>
        <span class="k">if</span> <span class="n">hypno</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">idx_sum</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># The detection using the three thresholds tends to underestimate the</span>
        <span class="c1"># real duration of the spindle. To overcome this, we compute a soft</span>
        <span class="c1"># threshold by smoothing the idx_sum vector with a 100 ms window.</span>
        <span class="n">w</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.1</span> <span class="o">*</span> <span class="n">sf</span><span class="p">)</span>
        <span class="n">idx_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">idx_sum</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">/</span> <span class="n">w</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">)</span>
        <span class="c1"># And we then find indices that are strictly greater than 2, i.e. we</span>
        <span class="c1"># find the &#39;true&#39; beginning and &#39;true&#39; end of the events by finding</span>
        <span class="c1"># where at least two out of the three treshold were crossed.</span>
        <span class="n">where_sp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">idx_sum</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">n_thresh</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># If no events are found, skip to next channel</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">where_sp</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;No spindle were found in channel </span><span class="si">%s</span><span class="s1">.&#39;</span><span class="p">,</span> <span class="n">ch_names</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">continue</span>

        <span class="c1"># Merge events that are too close</span>
        <span class="k">if</span> <span class="n">min_distance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">min_distance</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">where_sp</span> <span class="o">=</span> <span class="n">_merge_close</span><span class="p">(</span><span class="n">where_sp</span><span class="p">,</span> <span class="n">min_distance</span><span class="p">,</span> <span class="n">sf</span><span class="p">)</span>

        <span class="c1"># Extract start, end, and duration of each spindle</span>
        <span class="n">sp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">where_sp</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">where_sp</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">idx_start_end</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">k</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">sp</span><span class="p">])</span> <span class="o">/</span> <span class="n">sf</span>
        <span class="n">sp_start</span><span class="p">,</span> <span class="n">sp_end</span> <span class="o">=</span> <span class="n">idx_start_end</span><span class="o">.</span><span class="n">T</span>
        <span class="n">sp_dur</span> <span class="o">=</span> <span class="n">sp_end</span> <span class="o">-</span> <span class="n">sp_start</span>

        <span class="c1"># Find events with bad duration</span>
        <span class="n">good_dur</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">sp_dur</span> <span class="o">&gt;</span> <span class="n">duration</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sp_dur</span> <span class="o">&lt;</span> <span class="n">duration</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># If no events of good duration are found, skip to next channel</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="o">~</span><span class="n">good_dur</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;No spindle were found in channel </span><span class="si">%s</span><span class="s1">.&#39;</span><span class="p">,</span> <span class="n">ch_names</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">continue</span>

        <span class="c1"># Initialize empty variables</span>
        <span class="n">sp_amp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sp</span><span class="p">))</span>
        <span class="n">sp_freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sp</span><span class="p">))</span>
        <span class="n">sp_rms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sp</span><span class="p">))</span>
        <span class="n">sp_osc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sp</span><span class="p">))</span>
        <span class="n">sp_sym</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sp</span><span class="p">))</span>
        <span class="n">sp_abs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sp</span><span class="p">))</span>
        <span class="n">sp_rel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sp</span><span class="p">))</span>
        <span class="n">sp_sta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sp</span><span class="p">))</span>
        <span class="n">sp_pro</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sp</span><span class="p">))</span>
        <span class="c1"># sp_cou = np.zeros(len(sp))</span>

        <span class="c1"># Number of oscillations (number of peaks separated by at least 60 ms)</span>
        <span class="c1"># --&gt; 60 ms because 1000 ms / 16 Hz = 62.5 m, in other words, at 16 Hz,</span>
        <span class="c1"># peaks are separated by 62.5 ms. At 11 Hz peaks are separated by 90 ms</span>
        <span class="n">distance</span> <span class="o">=</span> <span class="mi">60</span> <span class="o">*</span> <span class="n">sf</span> <span class="o">/</span> <span class="mi">1000</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sp</span><span class="p">))[</span><span class="n">good_dur</span><span class="p">]:</span>
            <span class="c1"># Important: detrend the signal to avoid wrong PTP amplitude</span>
            <span class="n">sp_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">data_broad</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">sp</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="n">sp_det</span> <span class="o">=</span> <span class="n">_detrend</span><span class="p">(</span><span class="n">sp_x</span><span class="p">,</span> <span class="n">data_broad</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">sp</span><span class="p">[</span><span class="n">j</span><span class="p">]])</span>
            <span class="c1"># sp_det = signal.detrend(data_broad[i, sp[i]], type=&#39;linear&#39;)</span>
            <span class="n">sp_amp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ptp</span><span class="p">(</span><span class="n">sp_det</span><span class="p">)</span>  <span class="c1"># Peak-to-peak amplitude</span>
            <span class="n">sp_rms</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">_rms</span><span class="p">(</span><span class="n">sp_det</span><span class="p">)</span>  <span class="c1"># Root mean square</span>
            <span class="n">sp_rel</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">rel_pow</span><span class="p">[</span><span class="n">sp</span><span class="p">[</span><span class="n">j</span><span class="p">]])</span>  <span class="c1"># Median relative power</span>

            <span class="c1"># Hilbert-based instantaneous properties</span>
            <span class="n">sp_inst_freq</span> <span class="o">=</span> <span class="n">inst_freq</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">sp</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span>
            <span class="n">sp_inst_pow</span> <span class="o">=</span> <span class="n">inst_pow</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">sp</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span>
            <span class="n">sp_abs</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">sp_inst_pow</span><span class="p">[</span><span class="n">sp_inst_pow</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]))</span>
            <span class="n">sp_freq</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">sp_inst_freq</span><span class="p">[</span><span class="n">sp_inst_freq</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">])</span>

            <span class="c1"># Number of oscillations</span>
            <span class="n">peaks</span><span class="p">,</span> <span class="n">peaks_params</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">find_peaks</span><span class="p">(</span><span class="n">sp_det</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="n">distance</span><span class="p">,</span>
                                                    <span class="n">prominence</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
            <span class="n">sp_osc</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">peaks</span><span class="p">)</span>

            <span class="c1"># For frequency and amplitude, we can also optionally use these</span>
            <span class="c1"># faster alternatives. If we use them, we do not need to compute</span>
            <span class="c1"># the Hilbert transform of the filtered signal.</span>
            <span class="c1"># sp_freq[j] = sf / np.mean(np.diff(peaks))</span>
            <span class="c1"># sp_amp[j] = peaks_params[&#39;prominences&#39;].max()</span>

            <span class="c1"># Peak location &amp; symmetry index</span>
            <span class="c1"># pk is expressed in sample since the beginning of the spindle</span>
            <span class="n">pk</span> <span class="o">=</span> <span class="n">peaks</span><span class="p">[</span><span class="n">peaks_params</span><span class="p">[</span><span class="s1">&#39;prominences&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">argmax</span><span class="p">()]</span>
            <span class="n">sp_pro</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">sp_start</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">pk</span> <span class="o">/</span> <span class="n">sf</span>
            <span class="n">sp_sym</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">pk</span> <span class="o">/</span> <span class="n">sp_det</span><span class="o">.</span><span class="n">size</span>

            <span class="c1"># SO-spindles coupling</span>
            <span class="c1"># if coupling:</span>
            <span class="c1">#     sp_cou[j] = so_phase[i, sp[j]][pk]</span>

            <span class="c1"># Sleep stage</span>
            <span class="k">if</span> <span class="n">hypno</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">sp_sta</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">hypno</span><span class="p">[</span><span class="n">sp</span><span class="p">[</span><span class="n">j</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Create a dataframe</span>
        <span class="n">sp_params</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Start&#39;</span><span class="p">:</span> <span class="n">sp_start</span><span class="p">,</span>
                     <span class="s1">&#39;Peak&#39;</span><span class="p">:</span> <span class="n">sp_pro</span><span class="p">,</span>
                     <span class="s1">&#39;End&#39;</span><span class="p">:</span> <span class="n">sp_end</span><span class="p">,</span>
                     <span class="s1">&#39;Duration&#39;</span><span class="p">:</span> <span class="n">sp_dur</span><span class="p">,</span>
                     <span class="s1">&#39;Amplitude&#39;</span><span class="p">:</span> <span class="n">sp_amp</span><span class="p">,</span>
                     <span class="s1">&#39;RMS&#39;</span><span class="p">:</span> <span class="n">sp_rms</span><span class="p">,</span>
                     <span class="s1">&#39;AbsPower&#39;</span><span class="p">:</span> <span class="n">sp_abs</span><span class="p">,</span>
                     <span class="s1">&#39;RelPower&#39;</span><span class="p">:</span> <span class="n">sp_rel</span><span class="p">,</span>
                     <span class="s1">&#39;Frequency&#39;</span><span class="p">:</span> <span class="n">sp_freq</span><span class="p">,</span>
                     <span class="s1">&#39;Oscillations&#39;</span><span class="p">:</span> <span class="n">sp_osc</span><span class="p">,</span>
                     <span class="s1">&#39;Symmetry&#39;</span><span class="p">:</span> <span class="n">sp_sym</span><span class="p">,</span>
                     <span class="c1"># &#39;SOPhase&#39;: sp_cou,</span>
                     <span class="s1">&#39;Stage&#39;</span><span class="p">:</span> <span class="n">sp_sta</span><span class="p">}</span>

        <span class="n">df_chan</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">sp_params</span><span class="p">)[</span><span class="n">good_dur</span><span class="p">]</span>

        <span class="c1"># We need at least 50 detected spindles to apply the Isolation Forest.</span>
        <span class="k">if</span> <span class="n">remove_outliers</span> <span class="ow">and</span> <span class="n">df_chan</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">50</span><span class="p">:</span>
            <span class="n">col_keep</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Duration&#39;</span><span class="p">,</span> <span class="s1">&#39;Amplitude&#39;</span><span class="p">,</span> <span class="s1">&#39;RMS&#39;</span><span class="p">,</span> <span class="s1">&#39;AbsPower&#39;</span><span class="p">,</span> <span class="s1">&#39;RelPower&#39;</span><span class="p">,</span>
                        <span class="s1">&#39;Frequency&#39;</span><span class="p">,</span> <span class="s1">&#39;Oscillations&#39;</span><span class="p">,</span> <span class="s1">&#39;Symmetry&#39;</span><span class="p">]</span>
            <span class="n">ilf</span> <span class="o">=</span> <span class="n">IsolationForest</span><span class="p">(</span><span class="n">contamination</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">max_samples</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span>
                                  <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
            <span class="n">good</span> <span class="o">=</span> <span class="n">ilf</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">(</span><span class="n">df_chan</span><span class="p">[</span><span class="n">col_keep</span><span class="p">])</span>
            <span class="n">good</span><span class="p">[</span><span class="n">good</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%i</span><span class="s1"> outliers were removed in channel </span><span class="si">%s</span><span class="s1">.&#39;</span>
                        <span class="o">%</span> <span class="p">((</span><span class="n">good</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="n">ch_names</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="c1"># Remove outliers from DataFrame</span>
            <span class="n">df_chan</span> <span class="o">=</span> <span class="n">df_chan</span><span class="p">[</span><span class="n">good</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)]</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%i</span><span class="s1"> spindles were found in channel </span><span class="si">%s</span><span class="s1">.&#39;</span>
                        <span class="o">%</span> <span class="p">(</span><span class="n">df_chan</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ch_names</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

        <span class="c1"># ####################################################################</span>
        <span class="c1"># END SINGLE CHANNEL DETECTION</span>
        <span class="c1"># ####################################################################</span>
        <span class="n">df_chan</span><span class="p">[</span><span class="s1">&#39;Channel&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ch_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">df_chan</span><span class="p">[</span><span class="s1">&#39;IdxChannel&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df_chan</span><span class="p">,</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># If no spindles were detected, return None</span>
    <span class="k">if</span> <span class="n">df</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;No spindles were found in data. Returning None.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># Remove useless columns</span>
    <span class="n">to_drop</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">hypno</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">to_drop</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;Stage&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;Stage&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;Stage&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="c1"># if not coupling:</span>
    <span class="c1">#     to_drop.append(&#39;SOPhase&#39;)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">to_drop</span><span class="p">):</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">to_drop</span><span class="p">)</span>

    <span class="c1"># Find spindles that are present on at least two channels</span>
    <span class="k">if</span> <span class="n">multi_only</span> <span class="ow">and</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;Channel&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">nunique</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># We round to the nearest second</span>
        <span class="n">idx_good</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;Start&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">duplicated</span><span class="p">(</span><span class="n">keep</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
                                 <span class="n">df</span><span class="p">[</span><span class="s1">&#39;End&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">duplicated</span><span class="p">(</span><span class="n">keep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                                 <span class="p">)</span><span class="o">.</span><span class="n">to_list</span><span class="p">()</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">idx_good</span><span class="p">]</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">SpindlesResults</span><span class="p">(</span><span class="n">events</span><span class="o">=</span><span class="n">df</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">sf</span><span class="o">=</span><span class="n">sf</span><span class="p">,</span> <span class="n">ch_names</span><span class="o">=</span><span class="n">ch_names</span><span class="p">,</span>
                           <span class="n">hypno</span><span class="o">=</span><span class="n">hypno</span><span class="p">,</span> <span class="n">data_filt</span><span class="o">=</span><span class="n">data_sigma</span><span class="p">)</span></div>


<div class="viewcode-block" id="SpindlesResults"><a class="viewcode-back" href="../../generated/yasa.SpindlesResults.html#yasa.SpindlesResults">[docs]</a><span class="k">class</span> <span class="nc">SpindlesResults</span><span class="p">(</span><span class="n">_DetectionResults</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Output class for spindles detection.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    _events : :py:class:`pandas.DataFrame`</span>
<span class="sd">        Output detection dataframe</span>
<span class="sd">    _data : array_like</span>
<span class="sd">        Original EEG data of shape *(n_chan, n_samples)*.</span>
<span class="sd">    _data_filt : array_like</span>
<span class="sd">        Sigma-filtered EEG data of shape *(n_chan, n_samples)*.</span>
<span class="sd">    _sf : float</span>
<span class="sd">        Sampling frequency of data.</span>
<span class="sd">    _ch_names : list</span>
<span class="sd">        Channel names.</span>
<span class="sd">    _hypno : array_like or None</span>
<span class="sd">        Sleep staging vector.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="SpindlesResults.__init__"><a class="viewcode-back" href="../../generated/yasa.SpindlesResults.html#yasa.SpindlesResults.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">ch_names</span><span class="p">,</span> <span class="n">hypno</span><span class="p">,</span> <span class="n">data_filt</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">events</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">ch_names</span><span class="p">,</span> <span class="n">hypno</span><span class="p">,</span> <span class="n">data_filt</span><span class="p">)</span></div>

<div class="viewcode-block" id="SpindlesResults.summary"><a class="viewcode-back" href="../../generated/yasa.SpindlesResults.html#yasa.SpindlesResults.summary">[docs]</a>    <span class="k">def</span> <span class="nf">summary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grp_chan</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">grp_stage</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">aggfunc</span><span class="o">=</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span>
                <span class="n">sort</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a summary of the spindles detection, optionally grouped</span>
<span class="sd">        across channels and/or stage.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        grp_chan : bool</span>
<span class="sd">            If True, group by channel (for multi-channels detection only).</span>
<span class="sd">        grp_stage : bool</span>
<span class="sd">            If True, group by sleep stage (provided that an hypnogram was</span>
<span class="sd">            used).</span>
<span class="sd">        aggfunc : str or function</span>
<span class="sd">            Averaging function (e.g. ``&#39;mean&#39;`` or ``&#39;median&#39;``).</span>
<span class="sd">        sort : bool</span>
<span class="sd">            If True, sort group keys when grouping.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">summary</span><span class="p">(</span><span class="n">event_type</span><span class="o">=</span><span class="s1">&#39;spindles&#39;</span><span class="p">,</span>
                               <span class="n">grp_chan</span><span class="o">=</span><span class="n">grp_chan</span><span class="p">,</span> <span class="n">grp_stage</span><span class="o">=</span><span class="n">grp_stage</span><span class="p">,</span>
                               <span class="n">aggfunc</span><span class="o">=</span><span class="n">aggfunc</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="n">sort</span><span class="p">)</span></div>

<div class="viewcode-block" id="SpindlesResults.get_mask"><a class="viewcode-back" href="../../generated/yasa.SpindlesResults.html#yasa.SpindlesResults.get_mask">[docs]</a>    <span class="k">def</span> <span class="nf">get_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a boolean array indicating for each sample in data if this</span>
<span class="sd">        sample is part of a detected event (True) or not (False).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_mask</span><span class="p">()</span></div>

<div class="viewcode-block" id="SpindlesResults.get_sync_events"><a class="viewcode-back" href="../../generated/yasa.SpindlesResults.html#yasa.SpindlesResults.get_sync_events">[docs]</a>    <span class="k">def</span> <span class="nf">get_sync_events</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="s1">&#39;Peak&#39;</span><span class="p">,</span> <span class="n">time_before</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">time_after</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                        <span class="n">filt</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the raw or filtered data of each detected event after</span>
<span class="sd">        centering to a specific timepoint.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        center : str</span>
<span class="sd">            Landmark of the event to synchronize the timing on.</span>
<span class="sd">            Default is to use the center peak of the spindles.</span>
<span class="sd">        time_before : float</span>
<span class="sd">            Time (in seconds) before ``center``.</span>
<span class="sd">        time_after : float</span>
<span class="sd">            Time (in seconds) after ``center``.</span>
<span class="sd">        filt : tuple</span>
<span class="sd">            Optional filtering to apply to data. For instance, ``filt=(1, 30)``</span>
<span class="sd">            will apply a 1 to 30 Hz bandpass filter, and ``filt=(None, 40)``</span>
<span class="sd">            will apply a 40 Hz lowpass filter. Filtering is done using default</span>
<span class="sd">            parameters in the :py:func:`mne.filter.filter_data` function.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        df_sync : :py:class:`pandas.DataFrame`</span>
<span class="sd">            Long-format dataframe::</span>

<span class="sd">            &#39;Event&#39; : Event number</span>
<span class="sd">            &#39;Time&#39; : Timing of the events (in seconds)</span>
<span class="sd">            &#39;Amplitude&#39; : Raw or filtered data for event</span>
<span class="sd">            &#39;Channel&#39; : Channel</span>
<span class="sd">            &#39;IdxChannel&#39; : Index of channel in data</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_sync_events</span><span class="p">(</span><span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span> <span class="n">time_before</span><span class="o">=</span><span class="n">time_before</span><span class="p">,</span>
                                       <span class="n">time_after</span><span class="o">=</span><span class="n">time_after</span><span class="p">,</span>
                                       <span class="n">filt</span><span class="o">=</span><span class="n">filt</span><span class="p">)</span></div>

<div class="viewcode-block" id="SpindlesResults.plot_average"><a class="viewcode-back" href="../../generated/yasa.SpindlesResults.html#yasa.SpindlesResults.plot_average">[docs]</a>    <span class="k">def</span> <span class="nf">plot_average</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="s1">&#39;Peak&#39;</span><span class="p">,</span> <span class="n">time_before</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                     <span class="n">time_after</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">filt</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mf">4.5</span><span class="p">),</span>
                     <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the average spindle.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        center : str</span>
<span class="sd">            Landmark of the event to synchronize the timing on.</span>
<span class="sd">            Default is to use the most prominent peak of the spindle.</span>
<span class="sd">        time_before : float</span>
<span class="sd">            Time (in seconds) before ``center``.</span>
<span class="sd">        time_after : float</span>
<span class="sd">            Time (in seconds) after ``center``.</span>
<span class="sd">        filt : tuple</span>
<span class="sd">            Optional filtering to apply to data. For instance, ``filt=(1, 30)``</span>
<span class="sd">            will apply a 1 to 30 Hz bandpass filter, and ``filt=(None, 40)``</span>
<span class="sd">            will apply a 40 Hz lowpass filter. Filtering is done using default</span>
<span class="sd">            parameters in the :py:func:`mne.filter.filter_data` function.</span>
<span class="sd">        figsize : tuple</span>
<span class="sd">            Figure size in inches.</span>
<span class="sd">        **kwargs : dict</span>
<span class="sd">            Optional argument that are passed to :py:func:`seaborn.lineplot`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">plot_average</span><span class="p">(</span><span class="n">event_type</span><span class="o">=</span><span class="s1">&#39;spindles&#39;</span><span class="p">,</span>
                                    <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span> <span class="n">time_before</span><span class="o">=</span><span class="n">time_before</span><span class="p">,</span>
                                    <span class="n">time_after</span><span class="o">=</span><span class="n">time_after</span><span class="p">,</span> <span class="n">filt</span><span class="o">=</span><span class="n">filt</span><span class="p">,</span>
                                    <span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div></div>

<span class="c1">#############################################################################</span>
<span class="c1"># SLOW-WAVES DETECTION</span>
<span class="c1">#############################################################################</span>


<div class="viewcode-block" id="sw_detect"><a class="viewcode-back" href="../../generated/yasa.sw_detect.html#yasa.sw_detect">[docs]</a><span class="k">def</span> <span class="nf">sw_detect</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sf</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ch_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">hypno</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">include</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
              <span class="n">freq_sw</span><span class="o">=</span><span class="p">(</span><span class="mf">0.3</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dur_neg</span><span class="o">=</span><span class="p">(</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">),</span> <span class="n">dur_pos</span><span class="o">=</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
              <span class="n">amp_neg</span><span class="o">=</span><span class="p">(</span><span class="mi">40</span><span class="p">,</span> <span class="mi">300</span><span class="p">),</span> <span class="n">amp_pos</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">200</span><span class="p">),</span> <span class="n">amp_ptp</span><span class="o">=</span><span class="p">(</span><span class="mi">75</span><span class="p">,</span> <span class="mi">500</span><span class="p">),</span>
              <span class="n">coupling</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">freq_sp</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">16</span><span class="p">),</span> <span class="n">remove_outliers</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
              <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Slow-waves detection.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : array_like</span>
<span class="sd">        Single or multi-channel data. Unit must be uV and shape (n_samples) or</span>
<span class="sd">        (n_chan, n_samples). Can also be a :py:class:`mne.io.BaseRaw`,</span>
<span class="sd">        in which case ``data``, ``sf``, and ``ch_names`` will be automatically</span>
<span class="sd">        extracted, and ``data`` will also be automatically converted from</span>
<span class="sd">        Volts (MNE) to micro-Volts (YASA).</span>
<span class="sd">    sf : float</span>
<span class="sd">        Sampling frequency of the data in Hz.</span>
<span class="sd">        Can be omitted if ``data`` is a :py:class:`mne.io.BaseRaw`.</span>
<span class="sd">    ch_names : list of str</span>
<span class="sd">        Channel names. Can be omitted if ``data`` is a</span>
<span class="sd">        :py:class:`mne.io.BaseRaw`.</span>
<span class="sd">    hypno : array_like</span>
<span class="sd">        Sleep stage (hypnogram). If the hypnogram is loaded, the</span>
<span class="sd">        detection will only be applied to the value defined in</span>
<span class="sd">        ``include`` (default = N2 + N3 sleep).</span>

<span class="sd">        The hypnogram must have the same number of samples as ``data``.</span>
<span class="sd">        To upsample your hypnogram, please refer to</span>
<span class="sd">        :py:func:`yasa.hypno_upsample_to_data`.</span>

<span class="sd">        .. note::</span>
<span class="sd">            The default hypnogram format in YASA is a 1D integer</span>
<span class="sd">            vector where:</span>

<span class="sd">            - -2 = Unscored</span>
<span class="sd">            - -1 = Artefact / Movement</span>
<span class="sd">            - 0 = Wake</span>
<span class="sd">            - 1 = N1 sleep</span>
<span class="sd">            - 2 = N2 sleep</span>
<span class="sd">            - 3 = N3 sleep</span>
<span class="sd">            - 4 = REM sleep</span>
<span class="sd">    include : tuple, list or int</span>
<span class="sd">        Values in ``hypno`` that will be included in the mask. The default is</span>
<span class="sd">        (2, 3), meaning that the detection is applied on N2 and N3</span>
<span class="sd">        sleep. This has no effect when ``hypno`` is None.</span>
<span class="sd">    freq_sw : tuple or list</span>
<span class="sd">        Slow wave frequency range. Default is 0.3 to 2 Hz. Please note that</span>
<span class="sd">        YASA uses a FIR filter (implemented in MNE) with a 0.2 Hz transition</span>
<span class="sd">        band, which means that the -6 dB points are located at 0.2 and 2.1 Hz.</span>
<span class="sd">    dur_neg : tuple or list</span>
<span class="sd">        The minimum and maximum duration of the negative deflection of the</span>
<span class="sd">        slow wave. Default is 0.3 to 1.5 second.</span>
<span class="sd">    dur_pos : tuple or list</span>
<span class="sd">        The minimum and maximum duration of the positive deflection of the</span>
<span class="sd">        slow wave. Default is 0.1 to 1 second.</span>
<span class="sd">    amp_neg : tuple or list</span>
<span class="sd">        Absolute minimum and maximum negative trough amplitude of the</span>
<span class="sd">        slow-wave. Default is 40 uV to 300 uV. Can also be in unit of standard</span>
<span class="sd">        deviations if the data has been previously z-scored. If you do not want</span>
<span class="sd">        to specify any negative amplitude thresholds,</span>
<span class="sd">        use ``amp_neg=(None, None)``.</span>
<span class="sd">    amp_pos : tuple or list</span>
<span class="sd">        Absolute minimum and maximum positive peak amplitude of the</span>
<span class="sd">        slow-wave. Default is 10 uV to 200 uV. Can also be in unit of standard</span>
<span class="sd">        deviations if the data has been previously z-scored.</span>
<span class="sd">        If you do not want to specify any positive amplitude thresholds,</span>
<span class="sd">        use ``amp_pos=(None, None)``.</span>
<span class="sd">    amp_ptp : tuple or list</span>
<span class="sd">        Minimum and maximum peak-to-peak amplitude of the slow-wave.</span>
<span class="sd">        Default is 75 uV to 500 uV. Can also be in unit of standard</span>
<span class="sd">        deviations if the data has been previously z-scored.</span>
<span class="sd">        Use ``np.inf`` to set no upper amplitude threshold</span>
<span class="sd">        (e.g. ``amp_ptp=(75, np.inf)``).</span>
<span class="sd">    coupling : boolean</span>
<span class="sd">        If True, YASA will also calculate the phase-amplitude coupling between</span>
<span class="sd">        the slow-waves phase and the spindles-related sigma band</span>
<span class="sd">        amplitude. Specifically, two PAC metrics will be calculated:</span>

<span class="sd">        1. ``PhaseAtSigmaPeak``: the phase of the bandpas-filtered slow-wave</span>
<span class="sd">           signal (in radians) at the maximum sigma peak amplitude within an</span>
<span class="sd">           4-seconds epoch centered around the negative peak (through) of the</span>
<span class="sd">           current slow-wave.</span>

<span class="sd">           Importantly, since ``PhaseAtSigmaPeak`` is expressed in radians,</span>
<span class="sd">           one should use circular statistics to calculate the mean direction</span>
<span class="sd">           and vector length:</span>

<span class="sd">           .. code-block:: python</span>

<span class="sd">               import pingouin as pg</span>
<span class="sd">               mean_direction = pg.circ_mean(sw[&#39;PhaseAtSigmaPeak&#39;])</span>
<span class="sd">               vector_length = pg.circ_r(sw[&#39;PhaseAtSigmaPeak&#39;])</span>

<span class="sd">        2. ``ndPAC``: the normalized Mean Vector Length</span>
<span class="sd">           (also called the normalized direct PAC, or ndPAC) within a 4-sec</span>
<span class="sd">           epoch centered around the negative peak of the slow-wave.</span>

<span class="sd">        The lower and upper frequencies for the slow-waves and</span>
<span class="sd">        spindles-related sigma signals are defined in ``freq_sw`` and</span>
<span class="sd">        ``freq_sp``, respectively.</span>
<span class="sd">        For more details, please refer to the `Jupyter notebook</span>
<span class="sd">        &lt;https://github.com/raphaelvallat/yasa/blob/master/notebooks/12_spindles-SO_coupling.ipynb&gt;`_</span>

<span class="sd">        Note that setting ``coupling=True`` may significantly increase</span>
<span class="sd">        computation time.</span>

<span class="sd">        .. versionadded:: 0.2.0</span>

<span class="sd">    freq_sp : tuple or list</span>
<span class="sd">        Spindles-related frequency of interest. This is only relevant if</span>
<span class="sd">        ``coupling=True``. Default is 12 to 16 Hz, with a wide transition</span>
<span class="sd">        bandwidth of 1.5 Hz.</span>

<span class="sd">        .. versionadded:: 0.2.0</span>

<span class="sd">    remove_outliers : boolean</span>
<span class="sd">        If True, YASA will automatically detect and remove outliers slow-waves</span>
<span class="sd">        using :py:class:`sklearn.ensemble.IsolationForest`.</span>
<span class="sd">        The outliers detection is performed on the frequency, amplitude and</span>
<span class="sd">        duration parameters of the detected slow-waves. YASA uses a random seed</span>
<span class="sd">        (42) to ensure reproducible results. Note that this step will only be</span>
<span class="sd">        applied if there are more than 50 detected slow-waves in the first</span>
<span class="sd">        place. Default to False.</span>
<span class="sd">    verbose : bool or str</span>
<span class="sd">        Verbose level. Default (False) will only print warning and error</span>
<span class="sd">        messages. The logging levels are &#39;debug&#39;, &#39;info&#39;, &#39;warning&#39;, &#39;error&#39;,</span>
<span class="sd">        and &#39;critical&#39;. For most users the choice is between &#39;info&#39;</span>
<span class="sd">        (or ``verbose=True``) and warning (``verbose=False``).</span>

<span class="sd">        .. versionadded:: 0.2.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    sw : :py:class:`yasa.SWResults`</span>
<span class="sd">        To get the full detection dataframe, use:</span>

<span class="sd">        &gt;&gt;&gt; sw = sw_detect(...)</span>
<span class="sd">        &gt;&gt;&gt; sw.summary()</span>

<span class="sd">        This will give a :py:class:`pandas.DataFrame` where each row is a</span>
<span class="sd">        detected slow-wave and each column is a parameter (= property).</span>
<span class="sd">        To get the average SW parameters per channel and sleep stage:</span>

<span class="sd">        &gt;&gt;&gt; sw.summary(grp_chan=True, grp_stage=True)</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The parameters that are calculated for each slow-wave are:</span>

<span class="sd">    * ``&#39;Start&#39;``: Start time of each detected slow-wave, in seconds from the</span>
<span class="sd">      beginning of data.</span>
<span class="sd">    * ``&#39;NegPeak&#39;``: Location of the negative peak (in seconds)</span>
<span class="sd">    * ``&#39;MidCrossing&#39;``: Location of the negative-to-positive zero-crossing</span>
<span class="sd">      (in seconds)</span>
<span class="sd">    * ``&#39;Pospeak&#39;``: Location of the positive peak (in seconds)</span>
<span class="sd">    * ``&#39;End&#39;``: End time(in seconds)</span>
<span class="sd">    * ``&#39;Duration&#39;``: Duration (in seconds)</span>
<span class="sd">    * ``&#39;ValNegPeak&#39;``: Amplitude of the negative peak (in uV, calculated</span>
<span class="sd">      on the ``freq_sw`` bandpass-filtered signal)</span>
<span class="sd">    * ``&#39;ValPosPeak&#39;``: Amplitude of the positive peak (in uV, calculated</span>
<span class="sd">      on the ``freq_sw`` bandpass-filtered signal)</span>
<span class="sd">    * ``&#39;PTP&#39;``: Peak-to-peak amplitude (= ``ValPosPeak`` - ``ValNegPeak``,</span>
<span class="sd">      calculated on the ``freq_sw`` bandpass-filtered signal)</span>
<span class="sd">    * ``&#39;Slope&#39;``: Slope between ``NegPeak`` and ``MidCrossing`` (in uV/sec,</span>
<span class="sd">      calculated on the ``freq_sw`` bandpass-filtered signal)</span>
<span class="sd">    * ``&#39;Frequency&#39;``: Frequency of the slow-wave (= 1 / ``Duration``)</span>
<span class="sd">    * ``&#39;PhaseAtSigmaPeak&#39;``: SW phase at max sigma amplitude within a</span>
<span class="sd">      4-sec epoch centered the negative peak of the slow-wave. This is only</span>
<span class="sd">      calculated when ``coupling=True``</span>
<span class="sd">    * ``&#39;ndPAC&#39;``: Normalized direct PAC within a 4-sec epoch centered</span>
<span class="sd">      the negative peak of the slow-wave. This is only calculated when</span>
<span class="sd">      ``coupling=True``</span>
<span class="sd">    * ``&#39;Stage&#39;``: Sleep stage (only if hypno was provided)</span>

<span class="sd">    .. image:: https://raw.githubusercontent.com/raphaelvallat/yasa/master/docs/pictures/slow_waves.png  # noqa</span>
<span class="sd">      :width: 500px</span>
<span class="sd">      :align: center</span>
<span class="sd">      :alt: slow-wave</span>

<span class="sd">    For better results, apply this detection only on artefact-free NREM sleep.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    The slow-waves detection algorithm is based on:</span>

<span class="sd">    * Massimini, M., Huber, R., Ferrarelli, F., Hill, S., &amp; Tononi, G.</span>
<span class="sd">      (2004). `The sleep slow oscillation as a traveling wave.</span>
<span class="sd">      &lt;https://doi.org/10.1523/JNEUROSCI.1318-04.2004&gt;`_. The Journal of</span>
<span class="sd">      Neuroscience, 24(31), 6862–6870.</span>

<span class="sd">    * Carrier, J., Viens, I., Poirier, G., Robillard, R., Lafortune, M.,</span>
<span class="sd">      Vandewalle, G., Martin, N., Barakat, M., Paquet, J., &amp; Filipini, D.</span>
<span class="sd">      (2011). `Sleep slow wave changes during the middle years of life.</span>
<span class="sd">      &lt;https://doi.org/10.1111/j.1460-9568.2010.07543.x&gt;`_</span>
<span class="sd">      The European Journal of Neuroscience, 33(4), 758–766.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    For an example of how to run the detection, please refer to the tutorial:</span>
<span class="sd">    https://github.com/raphaelvallat/yasa/blob/master/notebooks/05_sw_detection.ipynb</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">set_log_level</span><span class="p">(</span><span class="n">verbose</span><span class="p">)</span>

    <span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">ch_names</span><span class="p">,</span> <span class="n">hypno</span><span class="p">,</span> <span class="n">include</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">n_chan</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">,</span> <span class="n">bad_chan</span>
     <span class="p">)</span> <span class="o">=</span> <span class="n">_check_data_hypno</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">ch_names</span><span class="p">,</span> <span class="n">hypno</span><span class="p">,</span> <span class="n">include</span><span class="p">)</span>

    <span class="c1"># If all channels are bad</span>
    <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">bad_chan</span><span class="p">)</span> <span class="o">==</span> <span class="n">n_chan</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;All channels have bad amplitude. Returning None.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># Define time vector</span>
    <span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="o">/</span> <span class="n">sf</span>
    <span class="n">idx_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Bandpass filter</span>
    <span class="n">nfast</span> <span class="o">=</span> <span class="n">next_fast_len</span><span class="p">(</span><span class="n">n_samples</span><span class="p">)</span>
    <span class="n">data_filt</span> <span class="o">=</span> <span class="n">filter_data</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">freq_sw</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">freq_sw</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;fir&#39;</span><span class="p">,</span>
                            <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">l_trans_bandwidth</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span>
                            <span class="n">h_trans_bandwidth</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>

    <span class="c1"># Extract the spindles-related sigma signal for coupling</span>
    <span class="k">if</span> <span class="n">coupling</span><span class="p">:</span>
        <span class="n">is_tensorpac_installed</span><span class="p">()</span>
        <span class="kn">import</span> <span class="nn">tensorpac.methods</span> <span class="k">as</span> <span class="nn">tpm</span>
        <span class="c1"># The width of the transition band is set to 1.5 Hz on each side,</span>
        <span class="c1"># meaning that for freq_sp = (12, 15 Hz), the -6 dB points are located</span>
        <span class="c1"># at 11.25 and 15.75 Hz. The frequency band for the amplitude signal</span>
        <span class="c1"># must be large enough to fit the sidebands caused by the assumed</span>
        <span class="c1"># modulating lower frequency band (Aru et al. 2015).</span>
        <span class="c1"># https://doi.org/10.1016/j.conb.2014.08.002</span>
        <span class="n">data_sp</span> <span class="o">=</span> <span class="n">filter_data</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">freq_sp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">freq_sp</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;fir&#39;</span><span class="p">,</span>
                              <span class="n">l_trans_bandwidth</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span> <span class="n">h_trans_bandwidth</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span>
                              <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># Now extract the instantaneous phase/amplitude using Hilbert transform</span>
        <span class="n">sw_pha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">hilbert</span><span class="p">(</span><span class="n">data_filt</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="n">nfast</span><span class="p">)[:,</span> <span class="p">:</span><span class="n">n_samples</span><span class="p">])</span>
        <span class="n">sp_amp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">hilbert</span><span class="p">(</span><span class="n">data_sp</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="n">nfast</span><span class="p">)[:,</span> <span class="p">:</span><span class="n">n_samples</span><span class="p">])</span>

    <span class="c1"># Initialize empty output dataframe</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_chan</span><span class="p">):</span>
        <span class="c1"># ####################################################################</span>
        <span class="c1"># START SINGLE CHANNEL DETECTION</span>
        <span class="c1"># ####################################################################</span>
        <span class="c1"># First, skip channels with bad data amplitude</span>
        <span class="k">if</span> <span class="n">bad_chan</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="k">continue</span>

        <span class="c1"># Find peaks in data</span>
        <span class="c1"># Negative peaks with value comprised between -40 to -300 uV</span>
        <span class="n">idx_neg_peaks</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">find_peaks</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">data_filt</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span>
                                             <span class="n">height</span><span class="o">=</span><span class="n">amp_neg</span><span class="p">)</span>
        <span class="c1"># Positive peaks with values comprised between 10 to 150 uV</span>
        <span class="n">idx_pos_peaks</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">find_peaks</span><span class="p">(</span><span class="n">data_filt</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="n">height</span><span class="o">=</span><span class="n">amp_pos</span><span class="p">)</span>
        <span class="c1"># Intersect with sleep stage vector</span>
        <span class="n">idx_neg_peaks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">idx_neg_peaks</span><span class="p">,</span> <span class="n">idx_mask</span><span class="p">,</span>
                                       <span class="n">assume_unique</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">idx_pos_peaks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">idx_pos_peaks</span><span class="p">,</span> <span class="n">idx_mask</span><span class="p">,</span>
                                       <span class="n">assume_unique</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># If no peaks are detected, return None</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx_neg_peaks</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx_pos_peaks</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;No SW were found in channel </span><span class="si">%s</span><span class="s1">.&#39;</span><span class="p">,</span> <span class="n">ch_names</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">continue</span>

        <span class="c1"># Make sure that the last detected peak is a positive one</span>
        <span class="k">if</span> <span class="n">idx_pos_peaks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">idx_neg_peaks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="c1"># If not, append a fake positive peak one sample after the last neg</span>
            <span class="n">idx_pos_peaks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx_pos_peaks</span><span class="p">,</span> <span class="n">idx_neg_peaks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># For each negative peak, we find the closest following positive peak</span>
        <span class="n">pk_sorted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">idx_pos_peaks</span><span class="p">,</span> <span class="n">idx_neg_peaks</span><span class="p">)</span>
        <span class="n">closest_pos_peaks</span> <span class="o">=</span> <span class="n">idx_pos_peaks</span><span class="p">[</span><span class="n">pk_sorted</span><span class="p">]</span> <span class="o">-</span> <span class="n">idx_neg_peaks</span>
        <span class="n">closest_pos_peaks</span> <span class="o">=</span> <span class="n">closest_pos_peaks</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">closest_pos_peaks</span><span class="p">)]</span>
        <span class="n">idx_pos_peaks</span> <span class="o">=</span> <span class="n">idx_neg_peaks</span> <span class="o">+</span> <span class="n">closest_pos_peaks</span>

        <span class="c1"># Now we compute the PTP amplitude and keep only the good peaks</span>
        <span class="n">sw_ptp</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">data_filt</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">idx_neg_peaks</span><span class="p">])</span> <span class="o">+</span>
                  <span class="n">data_filt</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">idx_pos_peaks</span><span class="p">])</span>
        <span class="n">good_ptp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">sw_ptp</span> <span class="o">&gt;</span> <span class="n">amp_ptp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sw_ptp</span> <span class="o">&lt;</span> <span class="n">amp_ptp</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># If good_ptp is all False</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="o">~</span><span class="n">good_ptp</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;No SW were found in channel </span><span class="si">%s</span><span class="s1">.&#39;</span><span class="p">,</span> <span class="n">ch_names</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">continue</span>

        <span class="n">sw_ptp</span> <span class="o">=</span> <span class="n">sw_ptp</span><span class="p">[</span><span class="n">good_ptp</span><span class="p">]</span>
        <span class="n">idx_neg_peaks</span> <span class="o">=</span> <span class="n">idx_neg_peaks</span><span class="p">[</span><span class="n">good_ptp</span><span class="p">]</span>
        <span class="n">idx_pos_peaks</span> <span class="o">=</span> <span class="n">idx_pos_peaks</span><span class="p">[</span><span class="n">good_ptp</span><span class="p">]</span>

        <span class="c1"># Now we need to check the negative and positive phase duration</span>
        <span class="c1"># For that we need to compute the zero crossings of the filtered signal</span>
        <span class="n">zero_crossings</span> <span class="o">=</span> <span class="n">_zerocrossings</span><span class="p">(</span><span class="n">data_filt</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:])</span>
        <span class="c1"># Make sure that there is a zero-crossing after the last detected peak</span>
        <span class="k">if</span> <span class="n">zero_crossings</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nb">max</span><span class="p">(</span><span class="n">idx_pos_peaks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">idx_neg_peaks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
            <span class="c1"># If not, append the index of the last peak</span>
            <span class="n">zero_crossings</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">zero_crossings</span><span class="p">,</span>
                                       <span class="nb">max</span><span class="p">(</span><span class="n">idx_pos_peaks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                                           <span class="n">idx_neg_peaks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

        <span class="c1"># Find distance to previous and following zc</span>
        <span class="n">neg_sorted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">zero_crossings</span><span class="p">,</span> <span class="n">idx_neg_peaks</span><span class="p">)</span>
        <span class="n">previous_neg_zc</span> <span class="o">=</span> <span class="n">zero_crossings</span><span class="p">[</span><span class="n">neg_sorted</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">idx_neg_peaks</span>
        <span class="n">following_neg_zc</span> <span class="o">=</span> <span class="n">zero_crossings</span><span class="p">[</span><span class="n">neg_sorted</span><span class="p">]</span> <span class="o">-</span> <span class="n">idx_neg_peaks</span>
        <span class="n">neg_phase_dur</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">previous_neg_zc</span><span class="p">)</span> <span class="o">+</span> <span class="n">following_neg_zc</span><span class="p">)</span> <span class="o">/</span> <span class="n">sf</span>

        <span class="c1"># Distance (in samples) between the positive peaks and the previous and</span>
        <span class="c1"># following zero-crossings</span>
        <span class="n">pos_sorted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">zero_crossings</span><span class="p">,</span> <span class="n">idx_pos_peaks</span><span class="p">)</span>
        <span class="n">previous_pos_zc</span> <span class="o">=</span> <span class="n">zero_crossings</span><span class="p">[</span><span class="n">pos_sorted</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">idx_pos_peaks</span>
        <span class="n">following_pos_zc</span> <span class="o">=</span> <span class="n">zero_crossings</span><span class="p">[</span><span class="n">pos_sorted</span><span class="p">]</span> <span class="o">-</span> <span class="n">idx_pos_peaks</span>
        <span class="n">pos_phase_dur</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">previous_pos_zc</span><span class="p">)</span> <span class="o">+</span> <span class="n">following_pos_zc</span><span class="p">)</span> <span class="o">/</span> <span class="n">sf</span>

        <span class="c1"># We now compute a set of metrics</span>
        <span class="n">sw_start</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="n">idx_neg_peaks</span> <span class="o">+</span> <span class="n">previous_neg_zc</span><span class="p">]</span>
        <span class="n">sw_end</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="n">idx_pos_peaks</span> <span class="o">+</span> <span class="n">following_pos_zc</span><span class="p">]</span>
        <span class="n">sw_dur</span> <span class="o">=</span> <span class="n">sw_end</span> <span class="o">-</span> <span class="n">sw_start</span>  <span class="c1"># Same as pos_phase_dur + neg_phase_dur</span>
        <span class="n">sw_midcrossing</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="n">idx_neg_peaks</span> <span class="o">+</span> <span class="n">following_neg_zc</span><span class="p">]</span>
        <span class="n">sw_idx_neg</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="n">idx_neg_peaks</span><span class="p">]</span>  <span class="c1"># Location of negative peak</span>
        <span class="n">sw_idx_pos</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="n">idx_pos_peaks</span><span class="p">]</span>  <span class="c1"># Location of positive peak</span>
        <span class="c1"># Slope between peak trough and midcrossing</span>
        <span class="n">sw_slope</span> <span class="o">=</span> <span class="n">sw_ptp</span> <span class="o">/</span> <span class="p">(</span><span class="n">sw_midcrossing</span> <span class="o">-</span> <span class="n">sw_idx_neg</span><span class="p">)</span>
        <span class="c1"># Hypnogram</span>
        <span class="k">if</span> <span class="n">hypno</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sw_sta</span> <span class="o">=</span> <span class="n">hypno</span><span class="p">[</span><span class="n">idx_neg_peaks</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sw_sta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">sw_dur</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="c1"># And we apply a set of thresholds to remove bad slow waves</span>
        <span class="n">good_sw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="o">.</span><span class="n">reduce</span><span class="p">((</span>
                                        <span class="c1"># Data edges</span>
                                        <span class="n">previous_neg_zc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span>
                                        <span class="n">following_neg_zc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span>
                                        <span class="n">previous_pos_zc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span>
                                        <span class="n">following_pos_zc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span>
                                        <span class="c1"># Duration criteria</span>
                                        <span class="n">neg_phase_dur</span> <span class="o">&gt;</span> <span class="n">dur_neg</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                        <span class="n">neg_phase_dur</span> <span class="o">&lt;</span> <span class="n">dur_neg</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                        <span class="n">pos_phase_dur</span> <span class="o">&gt;</span> <span class="n">dur_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                        <span class="n">pos_phase_dur</span> <span class="o">&lt;</span> <span class="n">dur_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                        <span class="c1"># Sanity checks</span>
                                        <span class="n">sw_midcrossing</span> <span class="o">&gt;</span> <span class="n">sw_start</span><span class="p">,</span>
                                        <span class="n">sw_midcrossing</span> <span class="o">&lt;</span> <span class="n">sw_end</span><span class="p">,</span>
                                        <span class="n">sw_slope</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span>
                                        <span class="p">))</span>

        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="o">~</span><span class="n">good_sw</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;No SW were found in channel </span><span class="si">%s</span><span class="s1">.&#39;</span><span class="p">,</span> <span class="n">ch_names</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">continue</span>

        <span class="c1"># Create a dictionnary and then a dataframe</span>
        <span class="n">sw_params</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">({</span><span class="s1">&#39;Start&#39;</span><span class="p">:</span> <span class="n">sw_start</span><span class="p">,</span>
                                 <span class="s1">&#39;NegPeak&#39;</span><span class="p">:</span> <span class="n">sw_idx_neg</span><span class="p">,</span>
                                 <span class="s1">&#39;MidCrossing&#39;</span><span class="p">:</span> <span class="n">sw_midcrossing</span><span class="p">,</span>
                                 <span class="s1">&#39;PosPeak&#39;</span><span class="p">:</span> <span class="n">sw_idx_pos</span><span class="p">,</span>
                                 <span class="s1">&#39;End&#39;</span><span class="p">:</span> <span class="n">sw_end</span><span class="p">,</span>
                                 <span class="s1">&#39;Duration&#39;</span><span class="p">:</span> <span class="n">sw_dur</span><span class="p">,</span>
                                 <span class="s1">&#39;ValNegPeak&#39;</span><span class="p">:</span> <span class="n">data_filt</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">idx_neg_peaks</span><span class="p">],</span>
                                 <span class="s1">&#39;ValPosPeak&#39;</span><span class="p">:</span> <span class="n">data_filt</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">idx_pos_peaks</span><span class="p">],</span>
                                 <span class="s1">&#39;PTP&#39;</span><span class="p">:</span> <span class="n">sw_ptp</span><span class="p">,</span>
                                 <span class="s1">&#39;Slope&#39;</span><span class="p">:</span> <span class="n">sw_slope</span><span class="p">,</span>
                                 <span class="s1">&#39;Frequency&#39;</span><span class="p">:</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">sw_dur</span><span class="p">,</span>
                                 <span class="s1">&#39;Stage&#39;</span><span class="p">:</span> <span class="n">sw_sta</span><span class="p">,</span>
                                 <span class="p">})</span>

        <span class="c1"># Add phase (in radians) of slow-oscillation signal at maximum</span>
        <span class="c1"># spindles-related sigma amplitude within a 4-seconds centered epochs.</span>
        <span class="k">if</span> <span class="n">coupling</span><span class="p">:</span>
            <span class="c1"># Get Phase and Amplitude for each centered epoch</span>
            <span class="n">time_before</span> <span class="o">=</span> <span class="n">time_after</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="n">bef</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sf</span> <span class="o">*</span> <span class="n">time_before</span><span class="p">)</span>
            <span class="n">aft</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sf</span> <span class="o">*</span> <span class="n">time_after</span><span class="p">)</span>
            <span class="n">n_peaks</span> <span class="o">=</span> <span class="n">idx_neg_peaks</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">idx</span><span class="p">,</span> <span class="n">idx_nomask</span> <span class="o">=</span> <span class="n">get_centered_indices</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="n">idx_neg_peaks</span><span class="p">,</span>
                                                   <span class="n">bef</span><span class="p">,</span> <span class="n">aft</span><span class="p">)</span>
            <span class="n">sw_pha_ev</span> <span class="o">=</span> <span class="n">sw_pha</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">idx</span><span class="p">]</span>
            <span class="n">sp_amp_ev</span> <span class="o">=</span> <span class="n">sp_amp</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">idx</span><span class="p">]</span>
            <span class="c1"># Find SW phase at max sigma amplitude in epoch</span>
            <span class="n">idx_max_amp</span> <span class="o">=</span> <span class="n">sp_amp_ev</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
            <span class="n">pha_at_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">take_along_axis</span><span class="p">(</span><span class="n">sw_pha_ev</span><span class="p">,</span> <span class="n">idx_max_amp</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">pha_at_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">pha_at_max</span><span class="p">)</span>
            <span class="c1"># Now we need to append it back to the original unmasked shape</span>
            <span class="n">pha_at_max_full</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n_peaks</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">pha_at_max_full</span><span class="p">[</span><span class="n">idx_nomask</span><span class="p">]</span> <span class="o">=</span> <span class="n">pha_at_max</span>
            <span class="n">sw_params</span><span class="p">[</span><span class="s1">&#39;PhaseAtSigmaPeak&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pha_at_max_full</span>
            <span class="c1"># Normalized Direct PAC, without thresholding</span>
            <span class="n">ndp</span> <span class="o">=</span> <span class="n">tpm</span><span class="o">.</span><span class="n">ndpac</span><span class="p">(</span><span class="n">sw_pha_ev</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">sp_amp_ev</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">p</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">ndp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">ndp</span><span class="p">)</span>
            <span class="n">ndp_full</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n_peaks</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">ndp_full</span><span class="p">[</span><span class="n">idx_nomask</span><span class="p">]</span> <span class="o">=</span> <span class="n">ndp</span>
            <span class="n">sw_params</span><span class="p">[</span><span class="s1">&#39;ndPAC&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ndp_full</span>
            <span class="c1"># Make sure that Stage is the last column of the dataframe</span>
            <span class="n">sw_params</span><span class="o">.</span><span class="n">move_to_end</span><span class="p">(</span><span class="s1">&#39;Stage&#39;</span><span class="p">)</span>

        <span class="c1"># Convert to dataframe, keeping only good events</span>
        <span class="n">df_chan</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">sw_params</span><span class="p">)[</span><span class="n">good_sw</span><span class="p">]</span>

        <span class="c1"># Remove all duplicates</span>
        <span class="n">df_chan</span> <span class="o">=</span> <span class="n">df_chan</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Start&#39;</span><span class="p">],</span> <span class="n">keep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">df_chan</span> <span class="o">=</span> <span class="n">df_chan</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;End&#39;</span><span class="p">],</span> <span class="n">keep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># We need at least 50 detected slow waves to apply the Isolation Forest</span>
        <span class="k">if</span> <span class="n">remove_outliers</span> <span class="ow">and</span> <span class="n">df_chan</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">50</span><span class="p">:</span>
            <span class="n">col_keep</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Duration&#39;</span><span class="p">,</span> <span class="s1">&#39;ValNegPeak&#39;</span><span class="p">,</span> <span class="s1">&#39;ValPosPeak&#39;</span><span class="p">,</span> <span class="s1">&#39;PTP&#39;</span><span class="p">,</span> <span class="s1">&#39;Slope&#39;</span><span class="p">,</span>
                        <span class="s1">&#39;Frequency&#39;</span><span class="p">]</span>
            <span class="n">ilf</span> <span class="o">=</span> <span class="n">IsolationForest</span><span class="p">(</span><span class="n">contamination</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">max_samples</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span>
                                  <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
            <span class="n">good</span> <span class="o">=</span> <span class="n">ilf</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">(</span><span class="n">df_chan</span><span class="p">[</span><span class="n">col_keep</span><span class="p">])</span>
            <span class="n">good</span><span class="p">[</span><span class="n">good</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%i</span><span class="s1"> outliers were removed in channel </span><span class="si">%s</span><span class="s1">.&#39;</span>
                        <span class="o">%</span> <span class="p">((</span><span class="n">good</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="n">ch_names</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="c1"># Remove outliers from DataFrame</span>
            <span class="n">df_chan</span> <span class="o">=</span> <span class="n">df_chan</span><span class="p">[</span><span class="n">good</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)]</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%i</span><span class="s1"> slow-waves were found in channel </span><span class="si">%s</span><span class="s1">.&#39;</span>
                        <span class="o">%</span> <span class="p">(</span><span class="n">df_chan</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ch_names</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

        <span class="c1"># ####################################################################</span>
        <span class="c1"># END SINGLE CHANNEL DETECTION</span>
        <span class="c1"># ####################################################################</span>

        <span class="n">df_chan</span><span class="p">[</span><span class="s1">&#39;Channel&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ch_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">df_chan</span><span class="p">[</span><span class="s1">&#39;IdxChannel&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df_chan</span><span class="p">,</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># If no SW were detected, return None</span>
    <span class="k">if</span> <span class="n">df</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;No SW were found in data. Returning None.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">hypno</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Stage&#39;</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;Stage&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;Stage&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">SWResults</span><span class="p">(</span><span class="n">events</span><span class="o">=</span><span class="n">df</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">sf</span><span class="o">=</span><span class="n">sf</span><span class="p">,</span> <span class="n">ch_names</span><span class="o">=</span><span class="n">ch_names</span><span class="p">,</span>
                     <span class="n">hypno</span><span class="o">=</span><span class="n">hypno</span><span class="p">,</span> <span class="n">data_filt</span><span class="o">=</span><span class="n">data_filt</span><span class="p">)</span></div>


<div class="viewcode-block" id="SWResults"><a class="viewcode-back" href="../../generated/yasa.SWResults.html#yasa.SWResults">[docs]</a><span class="k">class</span> <span class="nc">SWResults</span><span class="p">(</span><span class="n">_DetectionResults</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Output class for slow-waves detection.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    _events : :py:class:`pandas.DataFrame`</span>
<span class="sd">        Output detection dataframe</span>
<span class="sd">    _data : array_like</span>
<span class="sd">        EEG data of shape *(n_chan, n_samples)*.</span>
<span class="sd">    _data_filt : array_like</span>
<span class="sd">        Slow-wave filtered EEG data of shape *(n_chan, n_samples)*.</span>
<span class="sd">    _sf : float</span>
<span class="sd">        Sampling frequency of data.</span>
<span class="sd">    _ch_names : list</span>
<span class="sd">        Channel names.</span>
<span class="sd">    _hypno : array_like or None</span>
<span class="sd">        Sleep staging vector.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="SWResults.__init__"><a class="viewcode-back" href="../../generated/yasa.SWResults.html#yasa.SWResults.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">ch_names</span><span class="p">,</span> <span class="n">hypno</span><span class="p">,</span> <span class="n">data_filt</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">events</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">ch_names</span><span class="p">,</span> <span class="n">hypno</span><span class="p">,</span> <span class="n">data_filt</span><span class="p">)</span></div>

<div class="viewcode-block" id="SWResults.summary"><a class="viewcode-back" href="../../generated/yasa.SWResults.html#yasa.SWResults.summary">[docs]</a>    <span class="k">def</span> <span class="nf">summary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grp_chan</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">grp_stage</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">aggfunc</span><span class="o">=</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span>
                <span class="n">sort</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a summary of the SW detection, optionally grouped across</span>
<span class="sd">        channels and/or stage.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        grp_chan : bool</span>
<span class="sd">            If True, group by channel (for multi-channels detection only).</span>
<span class="sd">        grp_stage : bool</span>
<span class="sd">            If True, group by sleep stage (provided that an hypnogram was</span>
<span class="sd">            used).</span>
<span class="sd">        aggfunc : str or function</span>
<span class="sd">            Averaging function (e.g. ``&#39;mean&#39;`` or ``&#39;median&#39;``).</span>
<span class="sd">        sort : bool</span>
<span class="sd">            If True, sort group keys when grouping.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">summary</span><span class="p">(</span><span class="n">event_type</span><span class="o">=</span><span class="s1">&#39;sw&#39;</span><span class="p">,</span>
                               <span class="n">grp_chan</span><span class="o">=</span><span class="n">grp_chan</span><span class="p">,</span> <span class="n">grp_stage</span><span class="o">=</span><span class="n">grp_stage</span><span class="p">,</span>
                               <span class="n">aggfunc</span><span class="o">=</span><span class="n">aggfunc</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="n">sort</span><span class="p">)</span></div>

<div class="viewcode-block" id="SWResults.get_mask"><a class="viewcode-back" href="../../generated/yasa.SWResults.html#yasa.SWResults.get_mask">[docs]</a>    <span class="k">def</span> <span class="nf">get_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a boolean array indicating for each sample in data if this</span>
<span class="sd">        sample is part of a detected event (True) or not (False).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_mask</span><span class="p">()</span></div>

<div class="viewcode-block" id="SWResults.get_sync_events"><a class="viewcode-back" href="../../generated/yasa.SWResults.html#yasa.SWResults.get_sync_events">[docs]</a>    <span class="k">def</span> <span class="nf">get_sync_events</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="s1">&#39;NegPeak&#39;</span><span class="p">,</span> <span class="n">time_before</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span>
                        <span class="n">time_after</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">filt</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the raw data of each detected event after</span>
<span class="sd">        centering to a specific timepoint.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        center : str</span>
<span class="sd">            Landmark of the event to synchronize the timing on.</span>
<span class="sd">            Default is to use the negative peak of the slow-wave.</span>
<span class="sd">        time_before : float</span>
<span class="sd">            Time (in seconds) before ``center``.</span>
<span class="sd">        time_after : float</span>
<span class="sd">            Time (in seconds) after ``center``.</span>
<span class="sd">        filt : tuple</span>
<span class="sd">            Optional filtering to apply to data. For instance, ``filt=(1, 30)``</span>
<span class="sd">            will apply a 1 to 30 Hz bandpass filter, and ``filt=(None, 40)``</span>
<span class="sd">            will apply a 40 Hz lowpass filter. Filtering is done using default</span>
<span class="sd">            parameters in the :py:func:`mne.filter.filter_data` function.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        df_sync : :py:class:`pandas.DataFrame`</span>
<span class="sd">            Ouput long-format dataframe::</span>

<span class="sd">            &#39;Event&#39; : Event number</span>
<span class="sd">            &#39;Time&#39; : Timing of the events (in seconds)</span>
<span class="sd">            &#39;Amplitude&#39; : Raw data for event</span>
<span class="sd">            &#39;Chan&#39; : Channel (only in multi-channel detection)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_sync_events</span><span class="p">(</span><span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span> <span class="n">time_before</span><span class="o">=</span><span class="n">time_before</span><span class="p">,</span>
                                       <span class="n">time_after</span><span class="o">=</span><span class="n">time_after</span><span class="p">,</span>
                                       <span class="n">filt</span><span class="o">=</span><span class="n">filt</span><span class="p">)</span></div>

<div class="viewcode-block" id="SWResults.plot_average"><a class="viewcode-back" href="../../generated/yasa.SWResults.html#yasa.SWResults.plot_average">[docs]</a>    <span class="k">def</span> <span class="nf">plot_average</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="s1">&#39;NegPeak&#39;</span><span class="p">,</span> <span class="n">time_before</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span>
                     <span class="n">time_after</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">filt</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mf">4.5</span><span class="p">),</span>
                     <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the average slow-wave.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        center : str</span>
<span class="sd">            Landmark of the event to synchronize the timing on.</span>
<span class="sd">            Default is to use the negative peak of the slow-wave.</span>
<span class="sd">        time_before : float</span>
<span class="sd">            Time (in seconds) before ``center``.</span>
<span class="sd">        time_after : float</span>
<span class="sd">            Time (in seconds) after ``center``.</span>
<span class="sd">        filt : tuple</span>
<span class="sd">            Optional filtering to apply to data. For instance, ``filt=(1, 30)``</span>
<span class="sd">            will apply a 1 to 30 Hz bandpass filter, and ``filt=(None, 40)``</span>
<span class="sd">            will apply a 40 Hz lowpass filter. Filtering is done using default</span>
<span class="sd">            parameters in the :py:func:`mne.filter.filter_data` function.</span>
<span class="sd">        figsize : tuple</span>
<span class="sd">            Figure size in inches.</span>
<span class="sd">        **kwargs : dict</span>
<span class="sd">            Optional argument that are passed to :py:func:`seaborn.lineplot`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">plot_average</span><span class="p">(</span><span class="n">event_type</span><span class="o">=</span><span class="s1">&#39;sw&#39;</span><span class="p">,</span>
                                    <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span> <span class="n">time_before</span><span class="o">=</span><span class="n">time_before</span><span class="p">,</span>
                                    <span class="n">time_after</span><span class="o">=</span><span class="n">time_after</span><span class="p">,</span> <span class="n">filt</span><span class="o">=</span><span class="n">filt</span><span class="p">,</span>
                                    <span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div></div>


<span class="c1">#############################################################################</span>
<span class="c1"># REMs DETECTION</span>
<span class="c1">#############################################################################</span>


<div class="viewcode-block" id="rem_detect"><a class="viewcode-back" href="../../generated/yasa.rem_detect.html#yasa.rem_detect">[docs]</a><span class="k">def</span> <span class="nf">rem_detect</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">roc</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">hypno</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">include</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">amplitude</span><span class="o">=</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">325</span><span class="p">),</span>
               <span class="n">duration</span><span class="o">=</span><span class="p">(</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">),</span> <span class="n">freq_rem</span><span class="o">=</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">remove_outliers</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
               <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Rapid eye movements (REMs) detection.</span>

<span class="sd">    This detection requires both the left EOG (LOC) and right EOG (LOC).</span>
<span class="sd">    The units of the data must be uV. The algorithm is based on an amplitude</span>
<span class="sd">    thresholding of the negative product of the LOC and ROC</span>
<span class="sd">    filtered signal.</span>

<span class="sd">    .. versionadded:: 0.1.5</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    loc, roc : array_like</span>
<span class="sd">        Continuous EOG data (Left and Right Ocular Canthi, LOC / ROC) channels.</span>
<span class="sd">        Unit must be uV.</span>

<span class="sd">        .. warning::</span>
<span class="sd">            The default unit of :py:class:`mne.io.BaseRaw` is Volts.</span>
<span class="sd">            Therefore, if passing data from a :py:class:`mne.io.BaseRaw`,</span>
<span class="sd">            you need to multiply the data by 1e6 to convert to micro-Volts</span>
<span class="sd">            (1 V = 1,000,000 uV), e.g.:</span>

<span class="sd">            &gt;&gt;&gt; data = raw.get_data() * 1e6  # Make sure that data is in uV</span>
<span class="sd">    sf : float</span>
<span class="sd">        Sampling frequency of the data, in Hz.</span>
<span class="sd">    hypno : array_like</span>
<span class="sd">        Sleep stage (hypnogram). If the hypnogram is loaded, the</span>
<span class="sd">        detection will only be applied to the value defined in</span>
<span class="sd">        ``include`` (default = REM sleep).</span>

<span class="sd">        The hypnogram must have the same number of samples as ``data``.</span>
<span class="sd">        To upsample your hypnogram, please refer to</span>
<span class="sd">        :py:func:`yasa.hypno_upsample_to_data`.</span>

<span class="sd">        .. note::</span>
<span class="sd">            The default hypnogram format in YASA is a 1D integer</span>
<span class="sd">            vector where:</span>

<span class="sd">            - -2 = Unscored</span>
<span class="sd">            - -1 = Artefact / Movement</span>
<span class="sd">            - 0 = Wake</span>
<span class="sd">            - 1 = N1 sleep</span>
<span class="sd">            - 2 = N2 sleep</span>
<span class="sd">            - 3 = N3 sleep</span>
<span class="sd">            - 4 = REM sleep</span>
<span class="sd">    include : tuple, list or int</span>
<span class="sd">        Values in ``hypno`` that will be included in the mask. The default is</span>
<span class="sd">        (4), meaning that the detection is applied on REM sleep.</span>
<span class="sd">        This has no effect when ``hypno`` is None.</span>
<span class="sd">    amplitude : tuple or list</span>
<span class="sd">        Minimum and maximum amplitude of the peak of the REM.</span>
<span class="sd">        Default is 50 uV to 325 uV.</span>
<span class="sd">    duration : tuple or list</span>
<span class="sd">        The minimum and maximum duration of the REMs.</span>
<span class="sd">        Default is 0.3 to 1.2 seconds.</span>
<span class="sd">    freq_rem : tuple or list</span>
<span class="sd">        Frequency range of REMs. Default is 0.5 to 5 Hz.</span>
<span class="sd">    remove_outliers : boolean</span>
<span class="sd">        If True, YASA will automatically detect and remove outliers REMs</span>
<span class="sd">        using :py:class:`sklearn.ensemble.IsolationForest`.</span>
<span class="sd">        YASA uses a random seed (42) to ensure reproducible results.</span>
<span class="sd">        Note that this step will only be applied if there are more than</span>
<span class="sd">        50 detected REMs in the first place. Default to False.</span>
<span class="sd">    verbose : bool or str</span>
<span class="sd">        Verbose level. Default (False) will only print warning and error</span>
<span class="sd">        messages. The logging levels are &#39;debug&#39;, &#39;info&#39;, &#39;warning&#39;, &#39;error&#39;,</span>
<span class="sd">        and &#39;critical&#39;. For most users the choice is between &#39;info&#39;</span>
<span class="sd">        (or ``verbose=True``) and warning (``verbose=False``).</span>

<span class="sd">        .. versionadded:: 0.2.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    rem : :py:class:`yasa.REMResults`</span>
<span class="sd">        To get the full detection dataframe, use:</span>

<span class="sd">        &gt;&gt;&gt; rem = rem_detect(...)</span>
<span class="sd">        &gt;&gt;&gt; rem.summary()</span>

<span class="sd">        This will give a :py:class:`pandas.DataFrame` where each row is a</span>
<span class="sd">        detected REM and each column is a parameter (= property).</span>
<span class="sd">        To get the average parameters sleep stage:</span>

<span class="sd">        &gt;&gt;&gt; rem.summary(grp_stage=True)</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The parameters that are calculated for each REM are:</span>

<span class="sd">    * ``&#39;Start&#39;``: Start of each detected REM, in seconds from the</span>
<span class="sd">      beginning of data.</span>
<span class="sd">    * ``&#39;Peak&#39;``: Location of the peak (in seconds of data)</span>
<span class="sd">    * ``&#39;End&#39;``: End time (in seconds)</span>
<span class="sd">    * ``&#39;Duration&#39;``: Duration (in seconds)</span>
<span class="sd">    * ``&#39;LOCAbsValPeak&#39;``: LOC absolute amplitude at REM peak (in uV)</span>
<span class="sd">    * ``&#39;ROCAbsValPeak&#39;``: ROC absolute amplitude at REM peak (in uV)</span>
<span class="sd">    * ``&#39;LOCAbsRiseSlope&#39;``: LOC absolute rise slope (in uV/s)</span>
<span class="sd">    * ``&#39;ROCAbsRiseSlope&#39;``: ROC absolute rise slope (in uV/s)</span>
<span class="sd">    * ``&#39;LOCAbsFallSlope&#39;``: LOC absolute fall slope (in uV/s)</span>
<span class="sd">    * ``&#39;ROCAbsFallSlope&#39;``: ROC absolute fall slope (in uV/s)</span>
<span class="sd">    * ``&#39;Stage&#39;``: Sleep stage (only if hypno was provided)</span>

<span class="sd">    Note that all the output parameters are computed on the filtered LOC and</span>
<span class="sd">    ROC signals.</span>

<span class="sd">    For better results, apply this detection only on artefact-free REM sleep.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    The rapid eye movements detection algorithm is based on:</span>

<span class="sd">    * Agarwal, R., Takeuchi, T., Laroche, S., &amp; Gotman, J. (2005).</span>
<span class="sd">      `Detection of rapid-eye movements in sleep studies.</span>
<span class="sd">      &lt;https://doi.org/10.1109/TBME.2005.851512&gt;`_</span>
<span class="sd">      IEEE Transactions on Bio-Medical Engineering, 52(8), 1390–1396.</span>

<span class="sd">    * Yetton, B. D., Niknazar, M., Duggan, K. A., McDevitt, E. A., Whitehurst,</span>
<span class="sd">      L. N., Sattari, N., &amp; Mednick, S. C. (2016). `Automatic detection of</span>
<span class="sd">      rapid eye movements (REMs): A machine learning approach.</span>
<span class="sd">      &lt;https://doi.org/10.1016/j.jneumeth.2015.11.015&gt;`_</span>
<span class="sd">      Journal of Neuroscience Methods, 259, 72–82.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    For an example of how to run the detection, please refer to</span>
<span class="sd">    https://github.com/raphaelvallat/yasa/blob/master/notebooks/07_REMs_detection.ipynb</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">set_log_level</span><span class="p">(</span><span class="n">verbose</span><span class="p">)</span>
    <span class="c1"># Safety checks</span>
    <span class="n">loc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">))</span>
    <span class="n">roc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">roc</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">))</span>
    <span class="k">assert</span> <span class="n">loc</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;LOC must be 1D.&#39;</span>
    <span class="k">assert</span> <span class="n">roc</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;ROC must be 1D.&#39;</span>
    <span class="k">assert</span> <span class="n">loc</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">roc</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="s1">&#39;LOC and ROC must have the same size.&#39;</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">loc</span><span class="p">,</span> <span class="n">roc</span><span class="p">))</span>

    <span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">ch_names</span><span class="p">,</span> <span class="n">hypno</span><span class="p">,</span> <span class="n">include</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">n_chan</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">,</span> <span class="n">bad_chan</span>
     <span class="p">)</span> <span class="o">=</span> <span class="n">_check_data_hypno</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;LOC&#39;</span><span class="p">,</span> <span class="s1">&#39;ROC&#39;</span><span class="p">],</span> <span class="n">hypno</span><span class="p">,</span> <span class="n">include</span><span class="p">)</span>

    <span class="c1"># If all channels are bad</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">bad_chan</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;At least one channel has bad amplitude. &#39;</span>
                       <span class="s1">&#39;Returning None.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># Bandpass filter</span>
    <span class="n">data_filt</span> <span class="o">=</span> <span class="n">filter_data</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">freq_rem</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">freq_rem</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Calculate the negative product of LOC and ROC, maximal during REM.</span>
    <span class="n">negp</span> <span class="o">=</span> <span class="o">-</span><span class="n">data_filt</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">data_filt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>

    <span class="c1"># Find peaks in data</span>
    <span class="c1"># - height: required height of peaks (min and max.)</span>
    <span class="c1"># - distance: required distance in samples between neighboring peaks.</span>
    <span class="c1"># - prominence: required prominence of peaks.</span>
    <span class="c1"># - wlen: limit search for bases to a specific window.</span>
    <span class="n">hmin</span><span class="p">,</span> <span class="n">hmax</span> <span class="o">=</span> <span class="n">amplitude</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">amplitude</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">pks</span><span class="p">,</span> <span class="n">pks_params</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">find_peaks</span><span class="p">(</span><span class="n">negp</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="p">(</span><span class="n">hmin</span><span class="p">,</span> <span class="n">hmax</span><span class="p">),</span>
                                        <span class="n">distance</span><span class="o">=</span><span class="p">(</span><span class="n">duration</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">sf</span><span class="p">),</span>
                                        <span class="n">prominence</span><span class="o">=</span><span class="p">(</span><span class="mf">0.8</span> <span class="o">*</span> <span class="n">hmin</span><span class="p">),</span>
                                        <span class="n">wlen</span><span class="o">=</span><span class="p">(</span><span class="n">duration</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">sf</span><span class="p">))</span>

    <span class="c1"># Intersect with sleep stage vector</span>
    <span class="c1"># We do that before calculating the features in order to gain some time</span>
    <span class="n">idx_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">pks</span><span class="p">,</span> <span class="n">idx_good</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">pks</span><span class="p">,</span> <span class="n">idx_mask</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">pks_params</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">pks_params</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">pks_params</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">idx_good</span><span class="p">]</span>

    <span class="c1"># If no peaks are detected, return None</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pks</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;No REMs were found in data. Returning None.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># Hypnogram</span>
    <span class="k">if</span> <span class="n">hypno</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># The sleep stage at the beginning of the REM is considered.</span>
        <span class="n">rem_sta</span> <span class="o">=</span> <span class="n">hypno</span><span class="p">[</span><span class="n">pks_params</span><span class="p">[</span><span class="s1">&#39;left_bases&#39;</span><span class="p">]]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">rem_sta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">pks</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="c1"># Calculate time features</span>
    <span class="n">pks_params</span><span class="p">[</span><span class="s1">&#39;Start&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pks_params</span><span class="p">[</span><span class="s1">&#39;left_bases&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">sf</span>
    <span class="n">pks_params</span><span class="p">[</span><span class="s1">&#39;Peak&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pks</span> <span class="o">/</span> <span class="n">sf</span>
    <span class="n">pks_params</span><span class="p">[</span><span class="s1">&#39;End&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pks_params</span><span class="p">[</span><span class="s1">&#39;right_bases&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">sf</span>
    <span class="n">pks_params</span><span class="p">[</span><span class="s1">&#39;Duration&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pks_params</span><span class="p">[</span><span class="s1">&#39;End&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">pks_params</span><span class="p">[</span><span class="s1">&#39;Start&#39;</span><span class="p">]</span>
    <span class="c1"># Time points in minutes (HH:MM:SS)</span>
    <span class="c1"># pks_params[&#39;StartMin&#39;] = pd.to_timedelta(pks_params[&#39;Start&#39;], unit=&#39;s&#39;).dt.round(&#39;s&#39;)  # noqa</span>
    <span class="c1"># pks_params[&#39;PeakMin&#39;] = pd.to_timedelta(pks_params[&#39;Peak&#39;], unit=&#39;s&#39;).dt.round(&#39;s&#39;)  # noqa</span>
    <span class="c1"># pks_params[&#39;EndMin&#39;] = pd.to_timedelta(pks_params[&#39;End&#39;], unit=&#39;s&#39;).dt.round(&#39;s&#39;)  # noqa</span>
    <span class="c1"># Absolute LOC / ROC value at peak (filtered)</span>
    <span class="n">pks_params</span><span class="p">[</span><span class="s1">&#39;LOCAbsValPeak&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">data_filt</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">pks</span><span class="p">])</span>
    <span class="n">pks_params</span><span class="p">[</span><span class="s1">&#39;ROCAbsValPeak&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">data_filt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">pks</span><span class="p">])</span>
    <span class="c1"># Absolute rising and falling slope</span>
    <span class="n">dist_pk_left</span> <span class="o">=</span> <span class="p">(</span><span class="n">pks</span> <span class="o">-</span> <span class="n">pks_params</span><span class="p">[</span><span class="s1">&#39;left_bases&#39;</span><span class="p">])</span> <span class="o">/</span> <span class="n">sf</span>
    <span class="n">dist_pk_right</span> <span class="o">=</span> <span class="p">(</span><span class="n">pks_params</span><span class="p">[</span><span class="s1">&#39;right_bases&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">pks</span><span class="p">)</span> <span class="o">/</span> <span class="n">sf</span>
    <span class="n">locrs</span> <span class="o">=</span> <span class="p">(</span><span class="n">data_filt</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">pks</span><span class="p">]</span> <span class="o">-</span>
             <span class="n">data_filt</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">pks_params</span><span class="p">[</span><span class="s1">&#39;left_bases&#39;</span><span class="p">]])</span> <span class="o">/</span> <span class="n">dist_pk_left</span>
    <span class="n">rocrs</span> <span class="o">=</span> <span class="p">(</span><span class="n">data_filt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">pks</span><span class="p">]</span> <span class="o">-</span>
             <span class="n">data_filt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">pks_params</span><span class="p">[</span><span class="s1">&#39;left_bases&#39;</span><span class="p">]])</span> <span class="o">/</span> <span class="n">dist_pk_left</span>
    <span class="n">locfs</span> <span class="o">=</span> <span class="p">(</span><span class="n">data_filt</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">pks_params</span><span class="p">[</span><span class="s1">&#39;right_bases&#39;</span><span class="p">]]</span> <span class="o">-</span>
             <span class="n">data_filt</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">pks</span><span class="p">])</span> <span class="o">/</span> <span class="n">dist_pk_right</span>
    <span class="n">rocfs</span> <span class="o">=</span> <span class="p">(</span><span class="n">data_filt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">pks_params</span><span class="p">[</span><span class="s1">&#39;right_bases&#39;</span><span class="p">]]</span> <span class="o">-</span>
             <span class="n">data_filt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">pks</span><span class="p">])</span> <span class="o">/</span> <span class="n">dist_pk_right</span>
    <span class="n">pks_params</span><span class="p">[</span><span class="s1">&#39;LOCAbsRiseSlope&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">locrs</span><span class="p">)</span>
    <span class="n">pks_params</span><span class="p">[</span><span class="s1">&#39;ROCAbsRiseSlope&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">rocrs</span><span class="p">)</span>
    <span class="n">pks_params</span><span class="p">[</span><span class="s1">&#39;LOCAbsFallSlope&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">locfs</span><span class="p">)</span>
    <span class="n">pks_params</span><span class="p">[</span><span class="s1">&#39;ROCAbsFallSlope&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">rocfs</span><span class="p">)</span>
    <span class="n">pks_params</span><span class="p">[</span><span class="s1">&#39;Stage&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rem_sta</span>  <span class="c1"># Sleep stage</span>

    <span class="c1"># Convert to Pandas DataFrame</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">pks_params</span><span class="p">)</span>

    <span class="c1"># Make sure that the sign of ROC and LOC is opposite</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;IsOppositeSign&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">data_filt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">pks</span><span class="p">])</span> <span class="o">!=</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">data_filt</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">pks</span><span class="p">]))</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">data_filt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">pks</span><span class="p">])</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">data_filt</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">pks</span><span class="p">])]</span>

    <span class="c1"># Remove bad duration</span>
    <span class="n">tmin</span><span class="p">,</span> <span class="n">tmax</span> <span class="o">=</span> <span class="n">duration</span>
    <span class="n">good_dur</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">pks_params</span><span class="p">[</span><span class="s1">&#39;Duration&#39;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">tmin</span><span class="p">,</span>
                              <span class="n">pks_params</span><span class="p">[</span><span class="s1">&#39;Duration&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">tmax</span><span class="p">)</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">good_dur</span><span class="p">]</span>

    <span class="c1"># Keep only useful channels</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[[</span><span class="s1">&#39;Start&#39;</span><span class="p">,</span> <span class="s1">&#39;Peak&#39;</span><span class="p">,</span> <span class="s1">&#39;End&#39;</span><span class="p">,</span> <span class="s1">&#39;Duration&#39;</span><span class="p">,</span> <span class="s1">&#39;LOCAbsValPeak&#39;</span><span class="p">,</span>
             <span class="s1">&#39;ROCAbsValPeak&#39;</span><span class="p">,</span> <span class="s1">&#39;LOCAbsRiseSlope&#39;</span><span class="p">,</span> <span class="s1">&#39;ROCAbsRiseSlope&#39;</span><span class="p">,</span>
             <span class="s1">&#39;LOCAbsFallSlope&#39;</span><span class="p">,</span> <span class="s1">&#39;ROCAbsFallSlope&#39;</span><span class="p">,</span> <span class="s1">&#39;Stage&#39;</span><span class="p">]]</span>

    <span class="k">if</span> <span class="n">hypno</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Stage&#39;</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;Stage&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;Stage&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

    <span class="c1"># We need at least 100 detected REMs to apply the Isolation Forest.</span>
    <span class="k">if</span> <span class="n">remove_outliers</span> <span class="ow">and</span> <span class="n">df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">50</span><span class="p">:</span>
        <span class="n">col_keep</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Duration&#39;</span><span class="p">,</span> <span class="s1">&#39;LOCAbsValPeak&#39;</span><span class="p">,</span> <span class="s1">&#39;ROCAbsValPeak&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;LOCAbsRiseSlope&#39;</span><span class="p">,</span> <span class="s1">&#39;ROCAbsRiseSlope&#39;</span><span class="p">,</span> <span class="s1">&#39;LOCAbsFallSlope&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;ROCAbsFallSlope&#39;</span><span class="p">]</span>
        <span class="n">ilf</span> <span class="o">=</span> <span class="n">IsolationForest</span><span class="p">(</span><span class="n">contamination</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">max_samples</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span>
                              <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
        <span class="n">good</span> <span class="o">=</span> <span class="n">ilf</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">col_keep</span><span class="p">])</span>
        <span class="n">good</span><span class="p">[</span><span class="n">good</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%i</span><span class="s1"> outliers were removed.&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">good</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
        <span class="c1"># Remove outliers from DataFrame</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">good</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)]</span>

    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%i</span><span class="s1"> REMs were found in data.&#39;</span><span class="p">,</span> <span class="n">df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">REMResults</span><span class="p">(</span><span class="n">events</span><span class="o">=</span><span class="n">df</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">sf</span><span class="o">=</span><span class="n">sf</span><span class="p">,</span> <span class="n">ch_names</span><span class="o">=</span><span class="n">ch_names</span><span class="p">,</span>
                      <span class="n">hypno</span><span class="o">=</span><span class="n">hypno</span><span class="p">,</span> <span class="n">data_filt</span><span class="o">=</span><span class="n">data_filt</span><span class="p">)</span></div>


<div class="viewcode-block" id="REMResults"><a class="viewcode-back" href="../../generated/yasa.REMResults.html#yasa.REMResults">[docs]</a><span class="k">class</span> <span class="nc">REMResults</span><span class="p">(</span><span class="n">_DetectionResults</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Output class for REMs detection.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    _events : :py:class:`pandas.DataFrame`</span>
<span class="sd">        Output detection dataframe</span>
<span class="sd">    _data : array_like</span>
<span class="sd">        EOG data of shape *(n_chan, n_samples)*, where the two channels are</span>
<span class="sd">        LOC and ROC.</span>
<span class="sd">    _data_filt : array_like</span>
<span class="sd">        Filtered EOG data of shape *(n_chan, n_samples)*, where the two</span>
<span class="sd">        channels are LOC and ROC.</span>
<span class="sd">    _sf : float</span>
<span class="sd">        Sampling frequency of data.</span>
<span class="sd">    _ch_names : list</span>
<span class="sd">        Channel names (= ``[&#39;LOC&#39;, &#39;ROC&#39;]``)</span>
<span class="sd">    _hypno : array_like or None</span>
<span class="sd">        Sleep staging vector.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="REMResults.__init__"><a class="viewcode-back" href="../../generated/yasa.REMResults.html#yasa.REMResults.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">ch_names</span><span class="p">,</span> <span class="n">hypno</span><span class="p">,</span> <span class="n">data_filt</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">events</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">ch_names</span><span class="p">,</span> <span class="n">hypno</span><span class="p">,</span> <span class="n">data_filt</span><span class="p">)</span></div>

<div class="viewcode-block" id="REMResults.summary"><a class="viewcode-back" href="../../generated/yasa.REMResults.html#yasa.REMResults.summary">[docs]</a>    <span class="k">def</span> <span class="nf">summary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grp_stage</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">aggfunc</span><span class="o">=</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a summary of the REM detection, optionally grouped across</span>
<span class="sd">        stage.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        grp_stage : bool</span>
<span class="sd">            If True, group by sleep stage (provided that an hypnogram was</span>
<span class="sd">            used).</span>
<span class="sd">        aggfunc : str or function</span>
<span class="sd">            Averaging function (e.g. ``&#39;mean&#39;`` or ``&#39;median&#39;``).</span>
<span class="sd">        sort : bool</span>
<span class="sd">            If True, sort group keys when grouping.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># ``grp_chan`` is always False for REM detection because the</span>
        <span class="c1"># REMs are always detected on a combination of LOC and ROC.</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">summary</span><span class="p">(</span><span class="n">event_type</span><span class="o">=</span><span class="s1">&#39;rem&#39;</span><span class="p">,</span> <span class="n">grp_chan</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                               <span class="n">grp_stage</span><span class="o">=</span><span class="n">grp_stage</span><span class="p">,</span> <span class="n">aggfunc</span><span class="o">=</span><span class="n">aggfunc</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="n">sort</span><span class="p">)</span></div>

<div class="viewcode-block" id="REMResults.get_mask"><a class="viewcode-back" href="../../generated/yasa.REMResults.html#yasa.REMResults.get_mask">[docs]</a>    <span class="k">def</span> <span class="nf">get_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a boolean array indicating for each sample in data if this</span>
<span class="sd">        sample is part of a detected event (True) or not (False).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We cannot use super() because &quot;Channel&quot; is not present in _events.</span>
        <span class="kn">from</span> <span class="nn">yasa.others</span> <span class="k">import</span> <span class="n">_index_to_events</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">idx_ev</span> <span class="o">=</span> <span class="n">_index_to_events</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_events</span><span class="p">[[</span><span class="s1">&#39;Start&#39;</span><span class="p">,</span> <span class="s1">&#39;End&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sf</span><span class="p">)</span>
        <span class="n">mask</span><span class="p">[:,</span> <span class="n">idx_ev</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">mask</span></div>

<div class="viewcode-block" id="REMResults.get_sync_events"><a class="viewcode-back" href="../../generated/yasa.REMResults.html#yasa.REMResults.get_sync_events">[docs]</a>    <span class="k">def</span> <span class="nf">get_sync_events</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="s1">&#39;Peak&#39;</span><span class="p">,</span> <span class="n">time_before</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">time_after</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span>
                        <span class="n">filt</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the raw or filtered data of each detected event after</span>
<span class="sd">        centering to a specific timepoint.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        center : str</span>
<span class="sd">            Landmark of the event to synchronize the timing on.</span>
<span class="sd">            Default is to use the peak of the REM.</span>
<span class="sd">        time_before : float</span>
<span class="sd">            Time (in seconds) before ``center``.</span>
<span class="sd">        time_after : float</span>
<span class="sd">            Time (in seconds) after ``center``.</span>
<span class="sd">        filt : tuple</span>
<span class="sd">            Optional filtering to apply to data. For instance, ``filt=(1, 30)``</span>
<span class="sd">            will apply a 1 to 30 Hz bandpass filter, and ``filt=(None, 40)``</span>
<span class="sd">            will apply a 40 Hz lowpass filter. Filtering is done using default</span>
<span class="sd">            parameters in the :py:func:`mne.filter.filter_data` function.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        df_sync : :py:class:`pandas.DataFrame`</span>
<span class="sd">            Ouput long-format dataframe::</span>

<span class="sd">            &#39;Event&#39; : Event number</span>
<span class="sd">            &#39;Time&#39; : Timing of the events (in seconds)</span>
<span class="sd">            &#39;Amplitude&#39; : Raw data for event</span>
<span class="sd">            &#39;Chan&#39; : Channel</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">yasa.others</span> <span class="k">import</span> <span class="n">get_centered_indices</span>
        <span class="k">assert</span> <span class="n">time_before</span> <span class="o">&gt;=</span> <span class="mi">0</span>
        <span class="k">assert</span> <span class="n">time_after</span> <span class="o">&gt;=</span> <span class="mi">0</span>
        <span class="n">bef</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sf</span> <span class="o">*</span> <span class="n">time_before</span><span class="p">)</span>
        <span class="n">aft</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sf</span> <span class="o">*</span> <span class="n">time_after</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">filt</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">mne</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">filter_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sf</span><span class="p">,</span> <span class="n">l_freq</span><span class="o">=</span><span class="n">filt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                          <span class="n">h_freq</span><span class="o">=</span><span class="n">filt</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;fir&#39;</span><span class="p">,</span>
                                          <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>

        <span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">bef</span><span class="p">,</span> <span class="n">aft</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int&#39;</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sf</span>
        <span class="c1"># Get location of peaks in data</span>
        <span class="n">peaks</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_events</span><span class="p">[</span><span class="n">center</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sf</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="c1"># Get centered indices (here we could use second channel as well).</span>
        <span class="n">idx</span><span class="p">,</span> <span class="n">idx_nomask</span> <span class="o">=</span> <span class="n">get_centered_indices</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">peaks</span><span class="p">,</span> <span class="n">bef</span><span class="p">,</span> <span class="n">aft</span><span class="p">)</span>
        <span class="c1"># If no good epochs are returned raise a warning</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx_nomask</span><span class="p">),</span> <span class="p">(</span>
            <span class="s1">&#39;Time before and/or time after exceed data bounds, please &#39;</span>
            <span class="s1">&#39;lower the temporal window around center.&#39;</span><span class="p">)</span>

        <span class="c1"># Initialize empty dataframe</span>
        <span class="n">df_sync</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
        <span class="c1"># Loop across both EOGs (LOC and ROC)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ch</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ch_names</span><span class="p">):</span>
            <span class="n">amps</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">idx</span><span class="p">]</span>
            <span class="n">df_chan</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">amps</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="n">df_chan</span><span class="p">[</span><span class="s1">&#39;Time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span>
            <span class="n">df_chan</span> <span class="o">=</span> <span class="n">df_chan</span><span class="o">.</span><span class="n">melt</span><span class="p">(</span><span class="n">id_vars</span><span class="o">=</span><span class="s1">&#39;Time&#39;</span><span class="p">,</span> <span class="n">var_name</span><span class="o">=</span><span class="s1">&#39;Event&#39;</span><span class="p">,</span>
                                   <span class="n">value_name</span><span class="o">=</span><span class="s1">&#39;Amplitude&#39;</span><span class="p">)</span>
            <span class="n">df_chan</span><span class="p">[</span><span class="s1">&#39;Channel&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ch</span>
            <span class="n">df_chan</span><span class="p">[</span><span class="s1">&#39;IdxChannel&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
            <span class="n">df_sync</span> <span class="o">=</span> <span class="n">df_sync</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df_chan</span><span class="p">,</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">df_sync</span></div>

<div class="viewcode-block" id="REMResults.plot_average"><a class="viewcode-back" href="../../generated/yasa.REMResults.html#yasa.REMResults.plot_average">[docs]</a>    <span class="k">def</span> <span class="nf">plot_average</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="s1">&#39;Peak&#39;</span><span class="p">,</span> <span class="n">time_before</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span>
                     <span class="n">time_after</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">filt</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mf">4.5</span><span class="p">),</span>
                     <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the average REM.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        center : str</span>
<span class="sd">            Landmark of the event to synchronize the timing on.</span>
<span class="sd">            Default is to use the peak of the REM.</span>
<span class="sd">        time_before : float</span>
<span class="sd">            Time (in seconds) before ``center``.</span>
<span class="sd">        time_after : float</span>
<span class="sd">            Time (in seconds) after ``center``.</span>
<span class="sd">        filt : tuple</span>
<span class="sd">            Optional filtering to apply to data. For instance, ``filt=(1, 30)``</span>
<span class="sd">            will apply a 1 to 30 Hz bandpass filter, and ``filt=(None, 40)``</span>
<span class="sd">            will apply a 40 Hz lowpass filter. Filtering is done using default</span>
<span class="sd">            parameters in the :py:func:`mne.filter.filter_data` function.</span>
<span class="sd">        figsize : tuple</span>
<span class="sd">            Figure size in inches.</span>
<span class="sd">        **kwargs : dict</span>
<span class="sd">            Optional argument that are passed to :py:func:`seaborn.lineplot`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

        <span class="n">df_sync</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sync_events</span><span class="p">(</span><span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span> <span class="n">time_before</span><span class="o">=</span><span class="n">time_before</span><span class="p">,</span>
                                       <span class="n">time_after</span><span class="o">=</span><span class="n">time_after</span><span class="p">,</span> <span class="n">filt</span><span class="o">=</span><span class="n">filt</span><span class="p">)</span>

        <span class="c1"># Start figure</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">)</span>
        <span class="n">sns</span><span class="o">.</span><span class="n">lineplot</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">df_sync</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="s1">&#39;Time&#39;</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="s1">&#39;Amplitude&#39;</span><span class="p">,</span> <span class="n">hue</span><span class="o">=</span><span class="s1">&#39;Channel&#39;</span><span class="p">,</span>
                     <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># ax.legend(frameon=False, loc=&#39;lower right&#39;)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">df_sync</span><span class="p">[</span><span class="s1">&#39;Time&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">df_sync</span><span class="p">[</span><span class="s1">&#39;Time&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Average REM&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Time (sec)&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Amplitude (uV)&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ax</span></div></div>


<span class="c1">#############################################################################</span>
<span class="c1"># ARTEFACT DETECTION</span>
<span class="c1">#############################################################################</span>


<div class="viewcode-block" id="art_detect"><a class="viewcode-back" href="../../generated/yasa.art_detect.html#yasa.art_detect">[docs]</a><span class="k">def</span> <span class="nf">art_detect</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sf</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">hypno</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">include</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
               <span class="n">method</span><span class="o">=</span><span class="s1">&#39;covar&#39;</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_chan_reject</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Automatic artifact rejection.</span>

<span class="sd">    This is still an experimental feature. Expect API-breaking changes in</span>
<span class="sd">    future releases.</span>

<span class="sd">    .. versionadded:: 0.2.0</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : array_like</span>
<span class="sd">        Single or multi-channel EEG data.</span>
<span class="sd">        Unit must be uV and shape *(n_chan, n_samples)*.</span>
<span class="sd">        Can also be a :py:class:`mne.io.BaseRaw`, in which case ``data``</span>
<span class="sd">        and ``sf`` will be automatically extracted,</span>
<span class="sd">        and ``data`` will also be automatically converted from Volts (MNE)</span>
<span class="sd">        to micro-Volts (YASA).</span>

<span class="sd">        .. warning::</span>
<span class="sd">            ``data`` must only contains EEG channels. Please make sure to</span>
<span class="sd">            exclude any EOG, EKG or EMG channels.</span>
<span class="sd">    sf : float</span>
<span class="sd">        Sampling frequency of the data in Hz.</span>
<span class="sd">        Can be omitted if ``data`` is a :py:class:`mne.io.BaseRaw` object.</span>
<span class="sd">    window : float</span>
<span class="sd">        The window length (= resolution) for artifact rejection, in seconds.</span>
<span class="sd">        Default to 5 seconds. Shorter windows (e.g. 1 or 2-seconds) will</span>
<span class="sd">        drastically increase computation time when ``method=&#39;covar&#39;``.</span>
<span class="sd">    hypno : array_like</span>
<span class="sd">        Sleep stage (hypnogram). If the hypnogram is passed, the</span>
<span class="sd">        detection will be applied separately for each of the stages defined in</span>
<span class="sd">        ``include``.</span>

<span class="sd">        The hypnogram must have the same number of samples as ``data``.</span>
<span class="sd">        To upsample your hypnogram, please refer to</span>
<span class="sd">        :py:func:`yasa.hypno_upsample_to_data`.</span>

<span class="sd">        .. note::</span>
<span class="sd">            The default hypnogram format in YASA is a 1D integer</span>
<span class="sd">            vector where:</span>

<span class="sd">            - -2 = Unscored</span>
<span class="sd">            - -1 = Artefact / Movement</span>
<span class="sd">            - 0 = Wake</span>
<span class="sd">            - 1 = N1 sleep</span>
<span class="sd">            - 2 = N2 sleep</span>
<span class="sd">            - 3 = N3 sleep</span>
<span class="sd">            - 4 = REM sleep</span>
<span class="sd">    include : tuple, list or int</span>
<span class="sd">        Sleep stages in ``hypno`` on which to perform the artifact rejection.</span>
<span class="sd">        The default is ``hypno=(1, 2, 3, 4)``, meaning that the artifact</span>
<span class="sd">        rejection is applied separately for all sleep stages, excluding wake.</span>
<span class="sd">        This parameter has no effect when ``hypno`` is None.</span>
<span class="sd">    method : str</span>
<span class="sd">        Artifact detection method (see Notes):</span>

<span class="sd">        * ``&#39;covar&#39;`` : Covariance-based, default for 4+ channels data</span>
<span class="sd">        * ``&#39;std&#39;`` : Standard-deviation-based, default for single-channel data</span>
<span class="sd">    threshold : float</span>
<span class="sd">        The number of standard deviations above or below which an</span>
<span class="sd">        epoch is considered an artifact. Higher values will result in a more</span>
<span class="sd">        conservative detection, i.e. less rejected epochs.</span>
<span class="sd">    n_chan_reject : int</span>
<span class="sd">        The number of channels that must be below or above ``threshold`` on any</span>
<span class="sd">        given epochs to consider this epoch as an artefact when</span>
<span class="sd">        ``method=&#39;covar&#39;``. The default is 1, which means that the epoch will</span>
<span class="sd">        be marked as artifact as soon as one channel is above or below the</span>
<span class="sd">        threshold. This may be too conservative when working with a large</span>
<span class="sd">        number of channels (e.g.hdEEG) in which case users can increase</span>
<span class="sd">        ``n_chan_reject``. Note that this parameter only has an effect</span>
<span class="sd">        when ``method=&#39;covar&#39;``.</span>
<span class="sd">    verbose : bool or str</span>
<span class="sd">        Verbose level. Default (False) will only print warning and error</span>
<span class="sd">        messages. The logging levels are &#39;debug&#39;, &#39;info&#39;, &#39;warning&#39;, &#39;error&#39;,</span>
<span class="sd">        and &#39;critical&#39;. For most users the choice is between &#39;info&#39;</span>
<span class="sd">        (or ``verbose=True``) and warning (``verbose=False``).</span>

<span class="sd">        .. versionadded:: 0.2.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    art_epochs : array_like</span>
<span class="sd">        1-D array of shape *(n_epochs)* where 1 = Artefact and 0 = Good.</span>
<span class="sd">    zscores : array_like</span>
<span class="sd">        Array of z-scores, shape is *(n_epochs)* if ``method=&#39;covar&#39;`` and</span>
<span class="sd">        *(n_epochs, n_chan)* if ``method=&#39;std&#39;``.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    .. caution::</span>
<span class="sd">        This function will only detect major body artefacts present on the EEG</span>
<span class="sd">        channel. It will not detect EKG contamination or eye blinks. For more</span>
<span class="sd">        artifact rejection tools, please refer to the `MNE Python package</span>
<span class="sd">        &lt;https://mne.tools/stable/auto_tutorials/preprocessing/plot_10_preprocessing_overview.html&gt;`_.</span>

<span class="sd">    .. tip::</span>
<span class="sd">        For best performance, apply this function on pre-staged data and make</span>
<span class="sd">        sure to pass the hypnogram.</span>
<span class="sd">        Sleep stages have very different EEG signatures</span>
<span class="sd">        and the artifect rejection will be much more accurate when applied</span>
<span class="sd">        separately on each sleep stage.</span>

<span class="sd">    We provide below a short description of the different methods. For</span>
<span class="sd">    multi-channel data, and if computation time is not an issue, we recommend</span>
<span class="sd">    using ``method=&#39;covar&#39;`` which uses a clustering approach on</span>
<span class="sd">    variance-covariance matrices, and therefore takes into account</span>
<span class="sd">    not only the variance in each channel and each epoch, but also the</span>
<span class="sd">    inter-relationship (covariance) between channel.</span>

<span class="sd">    ``method=&#39;covar&#39;`` is however not supported for single-channel EEG or when</span>
<span class="sd">    less than 4 channels are present in ``data``. In these cases, one can</span>
<span class="sd">    use the much faster ``method=&#39;std&#39;`` which is simply based on a z-scoring</span>
<span class="sd">    of the log-transformed standard deviation of each channel and each epoch.</span>

<span class="sd">    **1/ Covariance-based multi-channel artefact rejection**</span>

<span class="sd">    ``method=&#39;covar&#39;`` is essentially a wrapper around the</span>
<span class="sd">    :py:class:`pyriemann.clustering.Potato` class implemented in the</span>
<span class="sd">    `pyRiemann package</span>
<span class="sd">    &lt;https://pyriemann.readthedocs.io/en/latest/index.html&gt;`_.</span>

<span class="sd">    The main idea of this approach is to estimate a reference covariance</span>
<span class="sd">    matrix :math:`\bar{C}` (for each sleep stage separately if ``hypno`` is</span>
<span class="sd">    present) and reject every epoch which is too far from this reference</span>
<span class="sd">    matrix.</span>
<span class="sd">    The distance of the covariance matrix of the current epoch :math:`C`</span>
<span class="sd">    from the reference matrix is calculated using Riemannian</span>
<span class="sd">    geometry, which is more adapted than Euclidean geometry for</span>
<span class="sd">    symmetric positive definite covariance matrices:</span>

<span class="sd">    .. math::  d = {\left( \sum_i \log(\lambda_i)^2 \right)}^{-1/2}</span>

<span class="sd">    where :math:`\lambda_i` are the joint eigenvalues of :math:`C` and</span>
<span class="sd">    :math:`\bar{C}`. The epoch with covariance matric :math:`C`</span>
<span class="sd">    will be marked as an artifact if the distance :math:`d`</span>
<span class="sd">    is greater than a threshold :math:`T`</span>
<span class="sd">    (typically 2 or 3 standard deviations).</span>
<span class="sd">    :math:`\bar{C}` is iteratively estimated using a clustering approach.</span>

<span class="sd">    **2/ Standard-deviation-based single and multi-channel artefact rejection**</span>

<span class="sd">    ``method=&#39;std&#39;`` is a much faster and straightforward approach which</span>
<span class="sd">    is simply based on the distribution of the standard deviations of each</span>
<span class="sd">    epoch. Specifically, one first calculate the standard</span>
<span class="sd">    deviations of each epoch and each channel. Then, the resulting array of</span>
<span class="sd">    standard deviations is log-transformed and z-scored (for each sleep</span>
<span class="sd">    stage separately if ``hypno`` is present). Any epoch with one or more</span>
<span class="sd">    channel exceeding the threshold will be marked as artifact.</span>

<span class="sd">    Note that this approach is more sensitive to noise and/or the influence of</span>
<span class="sd">    one bad channel (e.g. electrode fell off at some point during the night).</span>
<span class="sd">    We therefore recommend that you visually inspect and remove any bad</span>
<span class="sd">    channels prior to using this function.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    * Barachant, A., Andreev, A., &amp; Congedo, M. (2013). `The Riemannian</span>
<span class="sd">      Potato: an automatic and adaptive artifact detection method for online</span>
<span class="sd">      experiments using Riemannian geometry.</span>
<span class="sd">      &lt;https://hal.archives-ouvertes.fr/hal-00781701/&gt;`_ TOBI</span>
<span class="sd">      Workshop lV, 19–20.</span>

<span class="sd">    * Barthélemy, Q., Mayaud, L., Ojeda, D., &amp; Congedo, M. (2019).</span>
<span class="sd">      `The Riemannian Potato Field: A Tool for Online Signal Quality Index of</span>
<span class="sd">      EEG. &lt;https://doi.org/10.1109/TNSRE.2019.2893113&gt;`_</span>
<span class="sd">      IEEE Transactions on Neural Systems and Rehabilitation Engineering:</span>
<span class="sd">      A Publication of the IEEE Engineering in Medicine and Biology Society,</span>
<span class="sd">      27(2), 244–255.</span>

<span class="sd">    * https://pyriemann.readthedocs.io/en/latest/index.html</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    For an example of how to run the detection, please refer to</span>
<span class="sd">    https://github.com/raphaelvallat/yasa/blob/master/notebooks/13_artifact_rejection.ipynb</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">###########################################################################</span>
    <span class="c1"># PREPROCESSING</span>
    <span class="c1">###########################################################################</span>
    <span class="n">set_log_level</span><span class="p">(</span><span class="n">verbose</span><span class="p">)</span>

    <span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">hypno</span><span class="p">,</span> <span class="n">include</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">n_chan</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">,</span> <span class="n">_</span>
     <span class="p">)</span> <span class="o">=</span> <span class="n">_check_data_hypno</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">ch_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">hypno</span><span class="o">=</span><span class="n">hypno</span><span class="p">,</span>
                           <span class="n">include</span><span class="o">=</span><span class="n">include</span><span class="p">,</span> <span class="n">check_amp</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n_chan_reject</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="s1">&#39;n_chan_reject must be int.&#39;</span>
    <span class="k">assert</span> <span class="n">n_chan_reject</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;n_chan_reject must be &gt;= 1.&#39;</span>
    <span class="k">assert</span> <span class="n">n_chan_reject</span> <span class="o">&lt;=</span> <span class="n">n_chan</span><span class="p">,</span> <span class="s1">&#39;n_chan_reject must be &lt;= n_chan.&#39;</span>

    <span class="c1"># Safety check: sampling frequency and window</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sf</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)),</span> <span class="s1">&#39;sf must be int or float&#39;</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)),</span> <span class="s1">&#39;window must be int or float&#39;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sf</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">sf</span><span class="o">.</span><span class="n">is_integer</span><span class="p">(),</span> <span class="s1">&#39;sf must be a whole number.&#39;</span>
        <span class="n">sf</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sf</span><span class="p">)</span>
    <span class="n">win_sec</span> <span class="o">=</span> <span class="n">window</span>
    <span class="n">window</span> <span class="o">=</span> <span class="n">win_sec</span> <span class="o">*</span> <span class="n">sf</span>  <span class="c1"># Convert window to samples</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">window</span><span class="o">.</span><span class="n">is_integer</span><span class="p">(),</span> <span class="s1">&#39;window * sf must be a whole number.&#39;</span>
        <span class="n">window</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">window</span><span class="p">)</span>

    <span class="c1"># Safety check: hypnogram</span>
    <span class="k">if</span> <span class="n">hypno</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Extract hypnogram with only complete epochs</span>
        <span class="n">idx_max_full_epoch</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">n_samples</span> <span class="o">/</span> <span class="n">window</span><span class="p">))</span>
        <span class="n">hypno_win</span> <span class="o">=</span> <span class="n">hypno</span><span class="p">[::</span><span class="n">window</span><span class="p">][:</span><span class="n">idx_max_full_epoch</span><span class="p">]</span>

    <span class="c1"># Safety checks: methods</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="s2">&quot;method must be a string.&quot;</span>
    <span class="n">method</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;cov&#39;</span><span class="p">,</span> <span class="s1">&#39;covar&#39;</span><span class="p">,</span> <span class="s1">&#39;covariance&#39;</span><span class="p">,</span> <span class="s1">&#39;riemann&#39;</span><span class="p">,</span> <span class="s1">&#39;potato&#39;</span><span class="p">]:</span>
        <span class="n">method</span> <span class="o">=</span> <span class="s1">&#39;covar&#39;</span>
        <span class="n">is_pyriemann_installed</span><span class="p">()</span>
        <span class="kn">from</span> <span class="nn">pyriemann.estimation</span> <span class="k">import</span> <span class="n">Covariances</span><span class="p">,</span> <span class="n">Shrinkage</span>
        <span class="kn">from</span> <span class="nn">pyriemann.clustering</span> <span class="k">import</span> <span class="n">Potato</span>
        <span class="c1"># Must have at least 4 channels to use method=&#39;covar&#39;</span>
        <span class="k">if</span> <span class="n">n_chan</span> <span class="o">&lt;=</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Must have at least 4 channels for method=&#39;covar&#39;. &quot;</span>
                           <span class="s2">&quot;Automatically switching to method=&#39;std&#39;.&quot;</span><span class="p">)</span>
            <span class="n">method</span> <span class="o">=</span> <span class="s1">&#39;std&#39;</span>

    <span class="c1">###########################################################################</span>
    <span class="c1"># START THE REJECTION</span>
    <span class="c1">###########################################################################</span>
    <span class="c1"># Remove flat channels</span>
    <span class="n">isflat</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">isflat</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Flat channel(s) were found and removed in data.&#39;</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="o">~</span><span class="n">isflat</span><span class="p">]</span>
        <span class="n">n_chan</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Epoch the data (n_epochs, n_chan, n_samples)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">epochs</span> <span class="o">=</span> <span class="n">sliding_window</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">win_sec</span><span class="p">)</span>
    <span class="n">n_epochs</span> <span class="o">=</span> <span class="n">epochs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># We first need to identify epochs with flat data (n_epochs, n_chan)</span>
    <span class="n">isflat</span> <span class="o">=</span> <span class="p">(</span><span class="n">epochs</span> <span class="o">==</span> <span class="n">epochs</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">][</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">])</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># 1 when all channels are flat, 0 when none ar flat (n_epochs)</span>
    <span class="n">prop_chan_flat</span> <span class="o">=</span> <span class="n">isflat</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">n_chan</span>
    <span class="c1"># If &gt;= 50% of channels are flat, automatically mark as artefact</span>
    <span class="n">epoch_is_flat</span> <span class="o">=</span> <span class="n">prop_chan_flat</span> <span class="o">&gt;=</span> <span class="mf">0.5</span>
    <span class="n">where_flat_epochs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">epoch_is_flat</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">n_flat_epochs</span> <span class="o">=</span> <span class="n">where_flat_epochs</span><span class="o">.</span><span class="n">size</span>

    <span class="c1"># Now let&#39;s make sure that we have an hypnogram and an include variable</span>
    <span class="k">if</span> <span class="s1">&#39;hypno_win&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">locals</span><span class="p">():</span>
        <span class="c1"># [-2, -2, -2, -2, ...], where -2 stands for unscored</span>
        <span class="n">hypno_win</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n_epochs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float&#39;</span><span class="p">)</span>
        <span class="n">include</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float&#39;</span><span class="p">)</span>

    <span class="c1"># We want to make sure that hypno-win and n_epochs have EXACTLY same shape</span>
    <span class="k">assert</span> <span class="n">n_epochs</span> <span class="o">==</span> <span class="n">hypno_win</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;Hypno and epochs do not match.&#39;</span>

    <span class="c1"># Finally, we make sure not to include any flat epochs in calculation</span>
    <span class="c1"># just using a random number that is unlikely to be picked by users</span>
    <span class="k">if</span> <span class="n">n_flat_epochs</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">hypno_win</span><span class="p">[</span><span class="n">where_flat_epochs</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">111991</span>

    <span class="c1"># Add logger info</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Number of channels in data = </span><span class="si">%i</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">n_chan</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Number of samples in data = </span><span class="si">%i</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Sampling frequency = </span><span class="si">%.2f</span><span class="s1"> Hz&#39;</span><span class="p">,</span> <span class="n">sf</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Data duration = </span><span class="si">%.2f</span><span class="s1"> seconds&#39;</span><span class="p">,</span> <span class="n">n_samples</span> <span class="o">/</span> <span class="n">sf</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Number of epochs = </span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">n_epochs</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Artifact window = </span><span class="si">%.2f</span><span class="s1"> seconds&#39;</span> <span class="o">%</span> <span class="n">win_sec</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Method = </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">method</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Threshold = </span><span class="si">%.2f</span><span class="s1"> standard deviations&#39;</span> <span class="o">%</span> <span class="n">threshold</span><span class="p">)</span>

    <span class="c1"># Create empty `hypno_art` vector (1 sample = 1 epoch)</span>
    <span class="n">epoch_is_art</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_epochs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;covar&#39;</span><span class="p">:</span>
        <span class="c1"># Calculate the covariance matrices,</span>
        <span class="c1"># shape (n_epochs, n_chan, n_chan)</span>
        <span class="n">covmats</span> <span class="o">=</span> <span class="n">Covariances</span><span class="p">()</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">epochs</span><span class="p">)</span>
        <span class="c1"># Shrink the covariance matrix (ensure positive semi-definite)</span>
        <span class="n">covmats</span> <span class="o">=</span> <span class="n">Shrinkage</span><span class="p">()</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">covmats</span><span class="p">)</span>
        <span class="c1"># Define Potato instance: 0 = clean, 1 = art</span>
        <span class="c1"># To increase speed we set the max number of iterations from 10 to 100</span>
        <span class="n">potato</span> <span class="o">=</span> <span class="n">Potato</span><span class="p">(</span><span class="n">metric</span><span class="o">=</span><span class="s1">&#39;riemann&#39;</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span> <span class="n">pos_label</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                        <span class="n">neg_label</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_iter_max</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
        <span class="c1"># Create empty z-scores output (n_epochs)</span>
        <span class="n">zscores</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_epochs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float&#39;</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="k">for</span> <span class="n">stage</span> <span class="ow">in</span> <span class="n">include</span><span class="p">:</span>
            <span class="n">where_stage</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">hypno_win</span> <span class="o">==</span> <span class="n">stage</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># At least 30 epochs are required to calculate z-scores</span>
            <span class="c1"># which amounts to 2.5 minutes when using 5-seconds window</span>
            <span class="k">if</span> <span class="n">where_stage</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">30</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">hypno</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># Only show warnig if user actually pass an hypnogram</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;At least 30 epochs are required to &quot;</span>
                                   <span class="n">f</span><span class="s2">&quot;calculate z-score. Skipping &quot;</span>
                                   <span class="n">f</span><span class="s2">&quot;stage </span><span class="si">{stage}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="c1"># Apply Potato algorithm, extract z-scores and labels</span>
            <span class="n">zs</span> <span class="o">=</span> <span class="n">potato</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">covmats</span><span class="p">[</span><span class="n">where_stage</span><span class="p">])</span>
            <span class="n">art</span> <span class="o">=</span> <span class="n">potato</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">covmats</span><span class="p">[</span><span class="n">where_stage</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">hypno</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Only shows if user actually pass an hypnogram</span>
                <span class="n">perc_reject</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">*</span> <span class="p">(</span><span class="n">art</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">art</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
                <span class="n">text</span> <span class="o">=</span> <span class="p">(</span><span class="n">f</span><span class="s2">&quot;Stage </span><span class="si">{stage}</span><span class="s2">: {art.sum()} / </span><span class="si">{art.size}</span><span class="s2"> &quot;</span>
                        <span class="n">f</span><span class="s2">&quot;epochs rejected (</span><span class="si">{perc_reject:.2f}</span><span class="s2">%)&quot;</span><span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
            <span class="c1"># Append to global vector</span>
            <span class="n">epoch_is_art</span><span class="p">[</span><span class="n">where_stage</span><span class="p">]</span> <span class="o">=</span> <span class="n">art</span>
            <span class="n">zscores</span><span class="p">[</span><span class="n">where_stage</span><span class="p">]</span> <span class="o">=</span> <span class="n">zs</span>

    <span class="k">elif</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;std&#39;</span><span class="p">,</span> <span class="s1">&#39;sd&#39;</span><span class="p">]:</span>
        <span class="c1"># Calculate log-transformed standard dev in each epoch</span>
        <span class="c1"># We add 1 to avoid log warning id std is zero (e.g. flat line)</span>
        <span class="c1"># (n_epochs, n_chan)</span>
        <span class="n">std_epochs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">epochs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># Create empty zscores output (n_epochs, n_chan)</span>
        <span class="n">zscores</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_epochs</span><span class="p">,</span> <span class="n">n_chan</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float&#39;</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">for</span> <span class="n">stage</span> <span class="ow">in</span> <span class="n">include</span><span class="p">:</span>
            <span class="n">where_stage</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">hypno_win</span> <span class="o">==</span> <span class="n">stage</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># At least 30 epochs are required to calculate z-scores</span>
            <span class="c1"># which amounts to 2.5 minutes when using 5-seconds window</span>
            <span class="k">if</span> <span class="n">where_stage</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">30</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">hypno</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># Only show warnig if user actually pass an hypnogram</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;At least 30 epochs are required to &quot;</span>
                                   <span class="n">f</span><span class="s2">&quot;calculate z-score. Skipping &quot;</span>
                                   <span class="n">f</span><span class="s2">&quot;stage </span><span class="si">{stage}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="c1"># Calculate z-scores of STD for each channel x stage</span>
            <span class="n">c_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">std_epochs</span><span class="p">[</span><span class="n">where_stage</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">c_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">std_epochs</span><span class="p">[</span><span class="n">where_stage</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                              <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">zs</span> <span class="o">=</span> <span class="p">(</span><span class="n">std_epochs</span><span class="p">[</span><span class="n">where_stage</span><span class="p">]</span> <span class="o">-</span> <span class="n">c_mean</span><span class="p">)</span> <span class="o">/</span> <span class="n">c_std</span>
            <span class="c1"># Any epoch with at least X channel above or below threshold</span>
            <span class="n">n_chan_supra</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">zs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># &gt;</span>
            <span class="n">art</span> <span class="o">=</span> <span class="p">(</span><span class="n">n_chan_supra</span> <span class="o">&gt;=</span> <span class="n">n_chan_reject</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>  <span class="c1"># &gt;= !</span>
            <span class="k">if</span> <span class="n">hypno</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Only shows if user actually pass an hypnogram</span>
                <span class="n">perc_reject</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">*</span> <span class="p">(</span><span class="n">art</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">art</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
                <span class="n">text</span> <span class="o">=</span> <span class="p">(</span><span class="n">f</span><span class="s2">&quot;Stage </span><span class="si">{stage}</span><span class="s2">: {art.sum()} / </span><span class="si">{art.size}</span><span class="s2"> &quot;</span>
                        <span class="n">f</span><span class="s2">&quot;epochs rejected (</span><span class="si">{perc_reject:.2f}</span><span class="s2">%)&quot;</span><span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
            <span class="c1"># Append to global vector</span>
            <span class="n">epoch_is_art</span><span class="p">[</span><span class="n">where_stage</span><span class="p">]</span> <span class="o">=</span> <span class="n">art</span>
            <span class="n">zscores</span><span class="p">[</span><span class="n">where_stage</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">zs</span>

    <span class="c1"># Mark flat epochs as artefacts</span>
    <span class="k">if</span> <span class="n">n_flat_epochs</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Rejecting </span><span class="si">{n_flat_epochs}</span><span class="s2"> epochs with &gt;=50</span><span class="si">% o</span><span class="s2">f channels &quot;</span>
                    <span class="n">f</span><span class="s2">&quot;that are flat. Z-scores set to np.nan for these epochs.&quot;</span><span class="p">)</span>
        <span class="n">epoch_is_art</span><span class="p">[</span><span class="n">where_flat_epochs</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="c1"># Log total percentage of epochs rejected</span>
    <span class="n">perc_reject</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">*</span> <span class="p">(</span><span class="n">epoch_is_art</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">n_epochs</span><span class="p">)</span>
    <span class="n">text</span> <span class="o">=</span> <span class="p">(</span><span class="n">f</span><span class="s2">&quot;TOTAL: {epoch_is_art.sum()} / </span><span class="si">{n_epochs}</span><span class="s2"> &quot;</span>
            <span class="n">f</span><span class="s2">&quot;epochs rejected (</span><span class="si">{perc_reject:.2f}</span><span class="s2">%)&quot;</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>

    <span class="c1"># Convert epoch_is_art to boolean [0, 0, 1] -- &gt; [False, False, True]</span>
    <span class="n">epoch_is_art</span> <span class="o">=</span> <span class="n">epoch_is_art</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">epoch_is_art</span><span class="p">,</span> <span class="n">zscores</span></div>
</pre></div>

    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
        <br/>
        
      
    </p>
    <p>
        &copy; Copyright 2018-2020, Raphael Vallat.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.3.1.<br/>
    </p>
  </div>
</footer>
  </body>
</html>